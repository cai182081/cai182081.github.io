<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cailiang&#39;s Blog</title>
  
  <subtitle>飞翔的菜鸟</subtitle>
  <link href="/atom2.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-04T03:36:31.390Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>cai182081</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 事物与锁机制原理详解</title>
    <link href="http://yoursite.com/2018/05/03/MySQL/MySQL_Lock/"/>
    <id>http://yoursite.com/2018/05/03/MySQL/MySQL_Lock/</id>
    <published>2018-05-03T05:58:32.431Z</published>
    <updated>2018-05-04T03:36:31.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><p>事务（transaction）是数据库管理系统的执行单位，可以是一个数据库操作（如Select操作）或者是一组操作序列。事务ACID属性，即原子性（Atomicity）、一致性(Consistency)、隔离性（Isolation）、持久性（Durability）。</p><h2 id="事务四要素"><a href="#事务四要素" class="headerlink" title="事务四要素"></a>事务四要素</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性：事务包含的所有操作要么全部成功，要么全部失败回滚</span><br><span class="line">一致性：数据库从一个一致性状态变到另一个一致性状态</span><br><span class="line">隔离性：事务不能被其他事务的操作所干扰，多个并发事务之间相互隔离</span><br><span class="line">持久性：事务的提交结果，将持久保存在数据库中</span><br></pre></td></tr></table></figure><h2 id="事务隔离级别及区别"><a href="#事务隔离级别及区别" class="headerlink" title="事务隔离级别及区别"></a>事务隔离级别及区别</h2><p> 事务隔离级别（transaction isolation levels）：隔离级别就是对对事务并发控制的等级。ANSI/ ISO SQL将其分为串行化（SERIALIZABLE）、可重复读（REPEATABLE READ）、读已提交（READ COMMITED）、读未提交（READ UNCOMMITED）四个等级。为了实现隔离级别通常数据库采用锁（Lock）。一般在编程的时候只需要设置隔离等级，至于具体采用什么锁则由数据库来设置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Read Uncommitted（读未提交）：所有事务都可以看到其他未提交事务的执行结果。读取未提交的数据，也被称之为脏读（Dirty Read）。</span><br><span class="line">Read Committed（读已提交）：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</span><br><span class="line">Repeatable Read（可重复读）：确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。</span><br><span class="line">Serializable（串行化）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</span><br></pre></td></tr></table></figure></p><p>注：InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决不可重复读问题，而（Gap Lock）间隙锁机制解决幻读问题。<br><img src="/images/MySQL/Transaction_Isolation_Levels.png" alt="MySQL 事物隔离级别"></p><p>对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脏读（dirty <span class="built_in">read</span>）：一个事务可以读取另一个尚未提交事务的修改数据。</span><br><span class="line">非重复读（nonrepeatable <span class="built_in">read</span>）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。</span><br><span class="line">幻读（phantom <span class="built_in">read</span>）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差。</span><br></pre></td></tr></table></figure></p><h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><h2 id="MySQL-数据库锁机制背景"><a href="#MySQL-数据库锁机制背景" class="headerlink" title="MySQL 数据库锁机制背景"></a>MySQL 数据库锁机制背景</h2><p>数据库锁定机制简单来说，就是数据库为了保证事物的隔离性和一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。对于任何一种数据库来说都需要有相应的锁定机制，所以MySQL自然也不能例外。MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。MySQL各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。</p><h2 id="MySQL-锁类型"><a href="#MySQL-锁类型" class="headerlink" title="MySQL 锁类型"></a>MySQL 锁类型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）。</span><br><span class="line">行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。InnoDB、NDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</span><br><span class="line">页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁。</span><br></pre></td></tr></table></figure><h2 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h2><p>MySQL 的表级锁有两种模式，表共享读锁(table read lock)和表独占写锁（table write lock）</p><p>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；<br>对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；<br>MyISAM 表的读操作和写操作之间，以及写操作之间时串行的。当一个线程获得对一个表的写锁户，只有持有锁的线程可以对表进行更新操作，其他线程的读、写操作都会等待，直到锁被释放。</p><p>MyISAM存储引擎的读锁和写锁是互斥的，读写操作时串行的。当一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁时，写进程会先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前，这是因为 MySQL认为写请求一般比读请求重要。</p><h2 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h2><p>Innodb 实现了两种类型的行锁，另外为了允许行锁和表锁共存，事物多粒度锁机制，InnoDB 还有两种内部使用的意向锁，这两种意向锁是表锁：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</span><br><span class="line">排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务获取相同数据集的共享读锁和排他写锁。</span><br><span class="line">意向共享锁（IS）：事务试图给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</span><br><span class="line">意向排它锁（IX）: 事务试图给数据行加行排它锁，事务在给一个数据行加排它锁前必须先取得该表的 IX 锁。</span><br></pre></td></tr></table></figure></p><p><img src="/images/MySQL/Lock_Request.png" alt="MySQL 锁请求"></p><p>说明：如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是 InnoDB 内部使用的，不需要用户干预。</span><br><span class="line">2、对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。</span><br><span class="line">    共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。</span><br><span class="line">    排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE。</span><br><span class="line">3、InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</span><br></pre></td></tr></table></figure></p><p>InnoDB行锁实现方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">record lock：对索引项加锁</span><br><span class="line">gap lock：对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录的“间隙”加锁。</span><br><span class="line">next-key lock：record lock与gap lock的结合，对记录及其前面的间隙加锁。</span><br><span class="line">Insert Intention Locks：Gap Lock中存在一种插入意向锁（Insert Intention Lock），在 Insert 操作时产生。在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。</span><br></pre></td></tr></table></figure></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。</p><p>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</p><p>在事务中，如果要更新记录，应该申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。</p><p>在 repeatable-read 隔离级别下，如果两个线程同时对相同条件记录用 select … for update 加排他锁，在没有符合该条件记录情况下，两个线程过会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成 read committed ，就可避免问题。</p><p>当隔离级别为 read committed 时，如果两个线程都先执行 select … for update, 判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第 1 个线程提交后，第 2 个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁，如果有第 3 个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行 rollback 释放获得的排他锁。</p><p>处理锁相关的表：INFORMATION_SCHEMA 下INNODB_LOCKS、INNODB_LOCK_WAITS与INNODB_TRX。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;事物&quot;&gt;&lt;a href=&quot;#事物&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>函数、存储过程和试图定义者变更脚本</title>
    <link href="http://yoursite.com/2018/04/22/MySQL/MySQL_Change_Definder/"/>
    <id>http://yoursite.com/2018/04/22/MySQL/MySQL_Change_Definder/</id>
    <published>2018-04-21T23:08:30.964Z</published>
    <updated>2018-04-21T04:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 MySQL 数据库日常迁移过程中，由于操作的不规范性，常常因为函数、存储过程和视图定义者的缺失，导致存储过程、函数和视图失效，或者mysqldump逻辑备份无法备份和恢复。如果涉及的存储过程、函数和视图较多，一个一个的修改可能耗时和人为错误，所以特别设计函数批量修改存储过程、函数和视图的定义者，以减少运维维护量。这里默认将所有的定义者修改为‘root‘@’localhost’。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //  </span><br><span class="line">CREATE DEFINER = CURRENT_USER () PROCEDURE p_change_definer (</span><br><span class="line">`pr_database_name` VARCHAR (500), -- 数据库名称</span><br><span class="line">`pr_definer_name` VARCHAR (500), -- 定义者名称，默认 root</span><br><span class="line">`pr_definer_ip_name` VARCHAR (500) -- 定义者绑定ip，默认为 localhost</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">DECLARE drop_view_ varchar(500);</span><br><span class="line">DECLARE create_view_ varchar(15500);</span><br><span class="line">DECLARE DATABASE_NAME VARCHAR(500);</span><br><span class="line">DECLARE DEFINER_NAME VARCHAR(500) DEFAULT <span class="string">'root'</span>;</span><br><span class="line">DECLARE DEFINER_IP_NAME VARCHAR (500) DEFAULT <span class="string">'localhost'</span>;</span><br><span class="line">DECLARE flag boolean DEFAULT 1;</span><br><span class="line">DECLARE cur CURSOR FOR SELECT drop_view,create_view FROM sql_value;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NOT FOUND SET flag = 0;</span><br><span class="line"></span><br><span class="line">DROP TEMPORARY TABLE IF EXISTS sql_value; </span><br><span class="line">CREATE TEMPORARY TABLE sql_value(drop_view varchar(500),create_view varchar(15500));</span><br><span class="line"></span><br><span class="line">SET DATABASE_NAME = TRIM(pr_database_name);</span><br><span class="line"></span><br><span class="line">IF pr_definer_name IS NOT NULL AND LENGTH(pr_definer_name) &gt; 0 THEN</span><br><span class="line">SET DEFINER_NAME = TRIM(pr_definer_name);</span><br><span class="line">END IF;</span><br><span class="line">IF pr_definer_ip_name IS NOT NULL AND LENGTH(pr_definer_ip_name) &gt; 0 THEN</span><br><span class="line">SET DEFINER_IP_NAME = pr_definer_ip_name;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">-- 组装修改视图定义者语句</span><br><span class="line">IF DATABASE_NAME IS NOT NULL AND LENGTH(DATABASE_NAME) &gt;0 THEN</span><br><span class="line"> INSERT INTO sql_value</span><br><span class="line">  (drop_view, create_view)</span><br><span class="line">  SELECT GROUP_CONCAT(<span class="string">'DROP VIEW IF EXISTS '</span>, TABLE_SCHEMA, <span class="string">'.'</span>, TABLE_NAME, <span class="string">';'</span>),</span><br><span class="line">         GROUP_CONCAT(<span class="string">'CREATE ALGORITHM = UNDEFINED DEFINER = `'</span>, DEFINER_NAME, <span class="string">'`@`'</span>, DEFINER_IP_NAME, <span class="string">'` SQL SECURITY DEFINER VIEW `'</span>,</span><br><span class="line"> TABLE_SCHEMA, <span class="string">'`.`'</span>, TABLE_NAME, <span class="string">'` as '</span>, VIEW_DEFINITION, <span class="string">';'</span> SEPARATOR <span class="string">''</span>)</span><br><span class="line">    FROM information_schema.VIEWS</span><br><span class="line">   WHERE TABLE_SCHEMA = DATABASE_NAME</span><br><span class="line">   GROUP BY TABLE_NAME;</span><br><span class="line"></span><br><span class="line">-- 执行修改视图定义者</span><br><span class="line">OPEN cur;</span><br><span class="line"></span><br><span class="line">rep:LOOP</span><br><span class="line">  FETCH cur INTO drop_view_,create_view_;</span><br><span class="line">  <span class="built_in">set</span> @drop_view_ = drop_view_;</span><br><span class="line">  <span class="built_in">set</span> @create_view_ = create_view_;</span><br><span class="line">  IF flag = 0 THEN </span><br><span class="line">    LEAVE rep;</span><br><span class="line">  END IF;</span><br><span class="line"></span><br><span class="line">   PREPARE stmt FROM @drop_view_;</span><br><span class="line">   EXECUTE stmt;</span><br><span class="line">   DEALLOCATE PREPARE stmt;</span><br><span class="line">   PREPARE stmt FROM @create_view_;</span><br><span class="line">   EXECUTE stmt;</span><br><span class="line">   DEALLOCATE PREPARE stmt;</span><br><span class="line">END LOOP;</span><br><span class="line"></span><br><span class="line">CLOSE cur;</span><br><span class="line"></span><br><span class="line">-- 修改存储过程定义者</span><br><span class="line">UPDATE mysql.proc <span class="built_in">set</span> DEFINER = CONCAT(DEFINER_NAME,<span class="string">'@'</span>,DEFINER_IP_NAME) WHERE db = DATABASE_NAME;</span><br><span class="line"></span><br><span class="line">ELSE</span><br><span class="line">  SELECT <span class="string">'数据库名称不允许为空'</span>;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><p>修改执行命令为 ：<br>call p_change_definer(‘database’,’user’,’ip’);<br>database –需要修改的库名<br>user     –数据库的用户<br>IP       –数据库的绑定ip</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在 MySQL
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL 日常维护" scheme="http://yoursite.com/tags/MySQL-%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>SQL 优化之美：对一条简单 SQL 优化的理解、分析</title>
    <link href="http://yoursite.com/2018/04/21/SQL/DB_SQL_5/"/>
    <id>http://yoursite.com/2018/04/21/SQL/DB_SQL_5/</id>
    <published>2018-04-20T17:21:02.872Z</published>
    <updated>2018-05-03T10:04:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-SQL"><a href="#问题-SQL" class="headerlink" title="问题 SQL"></a>问题 SQL</h1><p>SQL执行时间0.8s,SQL文本如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT old_user_id, nick_name, channel, status</span><br><span class="line">  FROM user_relation</span><br><span class="line"> WHERE old_user_id IN</span><br><span class="line">       (SELECT old_user_id</span><br><span class="line">          FROM user_relation</span><br><span class="line">         WHERE old_user_id = <span class="string">'1601474800051044'</span></span><br><span class="line">            OR new_user_id = <span class="string">'1601474800051044'</span>)</span><br><span class="line">    OR new_user_id IN</span><br><span class="line">       (SELECT new_user_id</span><br><span class="line">          FROM user_relation</span><br><span class="line">         WHERE old_user_id = <span class="string">'1601474800051044'</span></span><br><span class="line">            OR new_user_id = <span class="string">'1601474800051044'</span>);</span><br></pre></td></tr></table></figure></p><p>表结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"user_relation"</span> (</span><br><span class="line">  <span class="string">"pay_organ_id"</span> varchar(50) NOT NULL,</span><br><span class="line">  <span class="string">"old_user_id"</span> varchar(32) DEFAULT NULL,</span><br><span class="line">  <span class="string">"new_user_id"</span> varchar(32) NOT NULL,</span><br><span class="line">  <span class="string">"nick_name"</span> varchar(15) DEFAULT NULL,</span><br><span class="line">  <span class="string">"channel"</span> char(1) DEFAULT NULL,</span><br><span class="line">  <span class="string">"status"</span> char(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (<span class="string">"pay_organ_id"</span>,<span class="string">"new_user_id"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_new_user_id"</span> (<span class="string">"new_user_id"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_old_user_id"</span> (<span class="string">"old_user_id"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>执行计划如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table          partitions  <span class="built_in">type</span>         possible_keys                      key                                key_len  ref        rows  filtered  Extra                                                        </span><br><span class="line">------  -----------  -------------  ----------  -----------  ---------------------------------  ---------------------------------  -------  ------  -------  --------  -------------------------------------------------------------</span><br><span class="line">     1  PRIMARY      user_relation  (NULL)      ALL          (NULL)                             (NULL)                             (NULL)   (NULL)  1124585    100.00  Using <span class="built_in">where</span>                                                  </span><br><span class="line">     3  SUBQUERY     user_relation  (NULL)      index_merge  uniq_new_user_id,uniq_old_user_id  uniq_old_user_id,uniq_new_user_id  99,98    (NULL)        2    100.00  Using union(uniq_old_user_id,uniq_new_user_id); Using <span class="built_in">where</span>  </span><br><span class="line">     2  SUBQUERY     user_relation  (NULL)      index_merge  uniq_new_user_id,uniq_old_user_id  uniq_old_user_id,uniq_new_user_id  99,98    (NULL)        2    100.00  Using union(uniq_old_user_id,uniq_new_user_id); Using <span class="built_in">where</span></span><br></pre></td></tr></table></figure></p><h1 id="SQL-性能瓶颈分析"><a href="#SQL-性能瓶颈分析" class="headerlink" title="SQL 性能瓶颈分析"></a>SQL 性能瓶颈分析</h1><p>从执行计划中可得知，MySQL优化器先后分别运算两个子查询后，再执行主查询，而主查询是经全表扫描后得到数据，主查询无法将谓词下推到子查询，通过索引检索，分析</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;问题-SQL&quot;&gt;&lt;a href=&quot;#问题-SQL&quot; class=&quot;headerlink&quot; title=&quot;问题 SQL&quot;&gt;&lt;/a&gt;问题 SQL&lt;/h1&gt;&lt;p&gt;SQL执行时间0.8s,SQL文本如下：&lt;br&gt;&lt;figure class=&quot;highlight
        
      
    
    </summary>
    
      <category term="SQL 优化" scheme="http://yoursite.com/categories/SQL-%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="数据库优化" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
      <category term="SQL 优化" scheme="http://yoursite.com/tags/SQL-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>pt-online-schema-change 实现原理及其用法</title>
    <link href="http://yoursite.com/2018/04/18/MySQL/MySQL_PT_OSC/"/>
    <id>http://yoursite.com/2018/04/18/MySQL/MySQL_PT_OSC/</id>
    <published>2018-04-18T11:48:56.126Z</published>
    <updated>2018-04-19T05:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pt-online-schema-change-背景"><a href="#pt-online-schema-change-背景" class="headerlink" title="pt-online-schema-change 背景"></a>pt-online-schema-change 背景</h1><p>pt-online-schema-change 用于MySQL的在线DDL操作</p><h1 id="pt-online-schema-change-使用限制"><a href="#pt-online-schema-change-使用限制" class="headerlink" title="pt-online-schema-change 使用限制"></a>pt-online-schema-change 使用限制</h1><p>1、原表必须存在主键 PRIMARY KEY 或者 UNIQUE KEY<br>2、原表不能存在触发器<br>3、外键的处理需要指定 alter-foreign-keys-method 参数<br>4、剩余的数据盘空间至少为原表大小的一倍</p><h1 id="pt-online-schema-change-实现原理"><a href="#pt-online-schema-change-实现原理" class="headerlink" title="pt-online-schema-change 实现原理"></a>pt-online-schema-change 实现原理</h1><p>pt-online-schema-change 修改表结构过程 general_log 日志内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">Connectroot@localhost on <span class="built_in">test</span> using Socket</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'innodb\_lock_wait_timeout'</span></span><br><span class="line">QuerySET SESSION innodb_lock_wait_timeout=1</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'lock\_wait_timeout'</span></span><br><span class="line">QuerySET SESSION lock_wait_timeout=60</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'wait\_timeout'</span></span><br><span class="line">QuerySET SESSION wait_timeout=10000</span><br><span class="line">QuerySELECT @@SQL_MODE</span><br><span class="line">QuerySET @@SQL_QUOTE_SHOW_CREATE = 1/*!40101, @@SQL_MODE=<span class="string">'NO_AUTO_VALUE_ON_ZERO,PIPES_AS_CONCAT,ANSI_QUOTES,NO_AUTO_VALUE_ON_ZERO,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span>*/</span><br><span class="line">QuerySELECT @@server_id /*!50038 , @@hostname*/</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'wsrep_on'</span></span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'version%'</span></span><br><span class="line">QuerySHOW ENGINES</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'innodb_version'</span></span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'innodb_stats_persistent'</span></span><br><span class="line">QuerySELECT @@SERVER_ID</span><br><span class="line">QuerySHOW SLAVE HOSTS</span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QuerySELECT CONCAT(@@hostname, @@port)</span><br><span class="line">QuerySHOW TABLES FROM `<span class="built_in">test</span>` LIKE <span class="string">'p\_test'</span></span><br><span class="line">QuerySELECT VERSION()</span><br><span class="line">QuerySHOW TRIGGERS FROM `<span class="built_in">test</span>` LIKE <span class="string">'p\_test'</span></span><br><span class="line">Query/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := <span class="string">''</span>, @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */</span><br><span class="line">QueryUSE `<span class="built_in">test</span>`</span><br><span class="line">QuerySHOW CREATE TABLE `<span class="built_in">test</span>`.`p_test`</span><br><span class="line">Query/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */</span><br><span class="line">QueryEXPLAIN SELECT * FROM `<span class="built_in">test</span>`.`p_test` WHERE 1=1</span><br><span class="line">QuerySELECT table_schema, table_name FROM information_schema.key_column_usage WHERE referenced_table_schema=<span class="string">'test'</span> AND referenced_table_name=<span class="string">'p_test'</span></span><br><span class="line">Query/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := <span class="string">''</span>, @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */</span><br><span class="line">QueryUSE `<span class="built_in">test</span>`</span><br><span class="line">QuerySHOW CREATE TABLE `<span class="built_in">test</span>`.`p_test`</span><br><span class="line">Query/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */</span><br><span class="line">QueryCREATE TABLE `<span class="built_in">test</span>`.`_p_test_new` (</span><br><span class="line">  `user_id` varchar(20) NOT NULL,</span><br><span class="line">  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">QueryALTER TABLE `<span class="built_in">test</span>`.`_p_test_new` ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST, DROP PRIMARY KEY, ADD PRIMARY KEY (id, create_time), ADD UNIQUE INDEX uniq_ui_ct(user_id, create_time)</span><br><span class="line">Query/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := <span class="string">''</span>, @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */</span><br><span class="line">QueryUSE `<span class="built_in">test</span>`</span><br><span class="line">QuerySHOW CREATE TABLE `<span class="built_in">test</span>`.`_p_test_new`</span><br><span class="line">Query/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */</span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'DELETE'</span>    AND ACTION_TIMING = <span class="string">'AFTER'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'UPDATE'</span>    AND ACTION_TIMING = <span class="string">'AFTER'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'INSERT'</span>    AND ACTION_TIMING = <span class="string">'AFTER'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'DELETE'</span>    AND ACTION_TIMING = <span class="string">'BEFORE'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'UPDATE'</span>    AND ACTION_TIMING = <span class="string">'BEFORE'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'INSERT'</span>    AND ACTION_TIMING = <span class="string">'BEFORE'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QueryCREATE TRIGGER `pt_osc_test_p_test_del` AFTER DELETE ON `<span class="built_in">test</span>`.`p_test` FOR EACH ROW DELETE IGNORE FROM `<span class="built_in">test</span>`.`_p_test_new` WHERE `<span class="built_in">test</span>`.`_p_test_new`.`user_id` &lt;=&gt; OLD.`user_id`</span><br><span class="line">QueryCREATE TRIGGER `pt_osc_test_p_test_upd` AFTER UPDATE ON `<span class="built_in">test</span>`.`p_test` FOR EACH ROW BEGIN DELETE IGNORE FROM `<span class="built_in">test</span>`.`_p_test_new` WHERE !(OLD.`user_id` &lt;=&gt; NEW.`user_id`) AND `<span class="built_in">test</span>`.`_p_test_new`.`user_id` &lt;=&gt; OLD.`user_id`;REPLACE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) VALUES (NEW.`user_id`, NEW.`create_time`);END</span><br><span class="line">QueryCREATE TRIGGER `pt_osc_test_p_test_ins` AFTER INSERT ON `<span class="built_in">test</span>`.`p_test` FOR EACH ROW REPLACE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) VALUES (NEW.`user_id`, NEW.`create_time`)</span><br><span class="line">QueryEXPLAIN SELECT * FROM `<span class="built_in">test</span>`.`p_test` WHERE 1=1</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) ORDER BY `user_id` LIMIT 1 /*first lower boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX (`PRIMARY`) WHERE `user_id` IS NOT NULL ORDER BY `user_id` LIMIT 1 /*key_len*/</span><br><span class="line">QueryEXPLAIN SELECT /*!40001 SQL_NO_CACHE */ * FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX (`PRIMARY`) WHERE `user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span> /*key_len*/</span><br><span class="line">QueryEXPLAIN SELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) ORDER BY `user_id` LIMIT 999, 2 /*next chunk boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) ORDER BY `user_id` LIMIT 999, 2 /*next chunk boundary*/</span><br><span class="line">QueryEXPLAIN SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) AND ((`user_id` &lt;= <span class="string">'bdn57bnaz9UXTpdFzH'</span>)) LOCK IN SHARE MODE /*explain pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QueryINSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) AND ((`user_id` &lt;= <span class="string">'bdn57bnaz9UXTpdFzH'</span>)) LOCK IN SHARE MODE /*pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QuerySHOW WARNINGS</span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QueryEXPLAIN SELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'bdo8j11Q2whGrZujWB'</span>)) ORDER BY `user_id` LIMIT 2237, 2 /*next chunk boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'bdo8j11Q2whGrZujWB'</span>)) ORDER BY `user_id` LIMIT 2237, 2 /*next chunk boundary*/</span><br><span class="line">QueryEXPLAIN SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'bdo8j11Q2whGrZujWB'</span>)) AND ((`user_id` &lt;= <span class="string">'Ox7PCp52KsU1fYXJAB'</span>)) LOCK IN SHARE MODE /*explain pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QueryINSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'bdo8j11Q2whGrZujWB'</span>)) AND ((`user_id` &lt;= <span class="string">'Ox7PCp52KsU1fYXJAB'</span>)) LOCK IN SHARE MODE /*pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QuerySHOW WARNINGS</span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QueryEXPLAIN SELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'OXcX149l9zca2yuCrc'</span>)) ORDER BY `user_id` LIMIT 2076, 2 /*next chunk boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'OXcX149l9zca2yuCrc'</span>)) ORDER BY `user_id` LIMIT 2076, 2 /*next chunk boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) ORDER BY `user_id` DESC LIMIT 1 /*last upper boundary*/</span><br><span class="line">QueryEXPLAIN SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'OXcX149l9zca2yuCrc'</span>)) AND ((`user_id` &lt;= <span class="string">'zzY2454Vegqcz6CC3i'</span>)) LOCK IN SHARE MODE /*explain pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QueryINSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'OXcX149l9zca2yuCrc'</span>)) AND ((`user_id` &lt;= <span class="string">'zzY2454Vegqcz6CC3i'</span>)) LOCK IN SHARE MODE /*pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QuerySHOW WARNINGS</span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QueryANALYZE TABLE `<span class="built_in">test</span>`.`_p_test_new` /* pt-online-schema-change */</span><br><span class="line">QueryRENAME TABLE `<span class="built_in">test</span>`.`p_test` TO `<span class="built_in">test</span>`.`_p_test_old`, `<span class="built_in">test</span>`.`_p_test_new` TO `<span class="built_in">test</span>`.`p_test`</span><br><span class="line">QueryDROP TABLE IF EXISTS `<span class="built_in">test</span>`.`_p_test_old`</span><br><span class="line">QueryDROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_del`</span><br><span class="line">QueryDROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_upd`</span><br><span class="line">QueryDROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_ins`</span><br><span class="line">QuerySHOW TABLES FROM `<span class="built_in">test</span>` LIKE <span class="string">'\_p\_test\_new'</span></span><br></pre></td></tr></table></figure></p><h2 id="连接数据库，获取指定表的状态信息、触发器信息、权限信息和主键信息"><a href="#连接数据库，获取指定表的状态信息、触发器信息、权限信息和主键信息" class="headerlink" title="连接数据库，获取指定表的状态信息、触发器信息、权限信息和主键信息"></a>连接数据库，获取指定表的状态信息、触发器信息、权限信息和主键信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost on <span class="built_in">test</span> using Socket</span><br><span class="line">SHOW TRIGGERS FROM `<span class="built_in">test</span>` LIKE <span class="string">'p\_test'</span></span><br><span class="line">SELECT table_schema, table_name FROM information_schema.key_column_usage WHERE referenced_table_schema=<span class="string">'test'</span> AND referenced_table_name=<span class="string">'p_test'</span></span><br><span class="line">SHOW CREATE TABLE `<span class="built_in">test</span>`.`p_test`</span><br></pre></td></tr></table></figure><h2 id="新建-new，表结构与原表相同。"><a href="#新建-new，表结构与原表相同。" class="headerlink" title="新建_*_new，表结构与原表相同。"></a>新建<code>_*_new</code>，表结构与原表相同。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `<span class="built_in">test</span>`.`_p_test_new` (</span><br><span class="line">  `user_id` varchar(20) NOT NULL,</span><br><span class="line">  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="在新表上执行DDL操作表结构，更改表结构"><a href="#在新表上执行DDL操作表结构，更改表结构" class="headerlink" title="在新表上执行DDL操作表结构，更改表结构"></a>在新表上执行DDL操作表结构，更改表结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `<span class="built_in">test</span>`.`_p_test_new` ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST, DROP PRIMARY KEY,ADD PRIMARY KEY (id);</span><br></pre></td></tr></table></figure><h2 id="在原表上分别针对insert、update、delete操作三个触发器分别，以便后续对原表上的操作同步到新表"><a href="#在原表上分别针对insert、update、delete操作三个触发器分别，以便后续对原表上的操作同步到新表" class="headerlink" title="在原表上分别针对insert、update、delete操作三个触发器分别，以便后续对原表上的操作同步到新表"></a>在原表上分别针对insert、update、delete操作三个触发器分别，以便后续对原表上的操作同步到新表</h2><p>Creating triggers ……<br>创建触发器，用于记录从拷贝数据开始之后，对源数据表继续进行数据修改的操作记录下来，用于数据拷贝结束后，执行这些操作，保证数据不会丢失。如果表中已经定义了触发器这个工具就不能工作了。我们可以看到这三个触发器分别对应于INSERT、UPDATE、DELETE三种操作：<br>  a、CREATE TRIGGER <code>pt_osc_test_p_test_del</code> AFTER DELETE ON <code>test</code>.<code>p_test</code> FOR EACH ROW DELETE IGNORE FROM <code>test</code>.<code>_p_test_new</code> WHERE <code>test</code>.<code>_p_test_new</code>.<code>user_id</code> &lt;=&gt; OLD.<code>user_id</code><br>  pt_osc_test_online_table_del，DELETE操作，我们注意到DELETE IGNORE，当新有数据时，我们才进行操作，也就是说，当在后续导入过程中，如果删除的这个数据还未导入到新表，那么我们可以不在新表执行操作，因为在以后的导入过程中，原表中改行数据已经被删除，已经没有数据，那么他也就不会导入到新表中。<br>  b、CREATE TRIGGER <code>pt_osc_test_p_test_upd</code> AFTER UPDATE ON <code>test</code>.<code>p_test</code> FOR EACH ROW BEGIN DELETE IGNORE FROM <code>test</code>.<code>_p_test_new</code> WHERE !(OLD.<code>user_id</code> &lt;=&gt; NEW.<code>user_id</code>) AND <code>test</code>.<code>_p_test_new</code>.<code>user_id</code> &lt;=&gt; OLD.<code>user_id</code>;REPLACE INTO <code>test</code>.<code>_p_test_new</code> (<code>user_id</code>, <code>create_time</code>) VALUES (NEW.<code>user_id</code>, NEW.<code>create_time</code>);END<br>  pt_osc_test_online_table_ins，INSERT操作，所有的INSERT INTO全部转换为REPLACE INTO，为了确保数据的一致性，当有新数据插入到原表时，如果触发器还未把原表数据未同步到新表，这条数据已经被导入到新表了，那么我们就可以利用replace into进行覆盖，这样数据也是一致的。<br>  c、 CREATE TRIGGER <code>pt_osc_test_p_test_ins</code> AFTER INSERT ON <code>test</code>.<code>p_test</code> FOR EACH ROW REPLACE INTO <code>test</code>.<code>_p_test_new</code> (<code>user_id</code>, <code>create_time</code>) VALUES (NEW.<code>user_id</code>, NEW.<code>create_time</code>)<br>  pt_osc_test_online_table_upd，UPDATE操作，所有的UPDATE也转换为REPLACE INTO，因为当新的数据的行还未同步到新表时，新表是不存在这条记录的，那么我们就只能插入该条数据，如果已经同步到新表了，那么也可以进行覆盖插入，所有数据与原表也是一致的。</p><h2 id="拷贝原表数据到新表，数据量大时根据主键进行分-chunk-段插入。"><a href="#拷贝原表数据到新表，数据量大时根据主键进行分-chunk-段插入。" class="headerlink" title="拷贝原表数据到新表，数据量大时根据主键进行分 chunk 段插入。"></a>拷贝原表数据到新表，数据量大时根据主键进行分 chunk 段插入。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) AND ((`user_id` &lt;= <span class="string">'bdn57bnaz9UXTpdFzH'</span>)) LOCK IN SHARE MODE /*pt-online-schema-change 31941 copy nibble*/</span><br></pre></td></tr></table></figure><p>数据的拷贝是基于chunk指定的大小块(根据chunk-time参数指定)进行的，而且根据主键或者唯一索引索引进行选择，所以对整体服务器性能影响较小。它是通过一些查询（基本为主键、唯一键值）分批把数据导入到新的表中。在拷贝过程中，数据库通过对主键加S锁，拷贝数据。</p><h2 id="ANALYZE重新收集新表统计信息"><a href="#ANALYZE重新收集新表统计信息" class="headerlink" title="ANALYZE重新收集新表统计信息"></a>ANALYZE重新收集新表统计信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE TABLE `<span class="built_in">test</span>`.`_p_test_new`</span><br></pre></td></tr></table></figure><h2 id="交换表，其通过一个RENAME-TABLE同时处理两个表，实现原子操作。"><a href="#交换表，其通过一个RENAME-TABLE同时处理两个表，实现原子操作。" class="headerlink" title="交换表，其通过一个RENAME TABLE同时处理两个表，实现原子操作。"></a>交换表，其通过一个RENAME TABLE同时处理两个表，实现原子操作。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE `<span class="built_in">test</span>`.`p_test` TO `<span class="built_in">test</span>`.`_p_test_old`, `<span class="built_in">test</span>`.`_p_test_new` TO `<span class="built_in">test</span>`.`p_test`</span><br></pre></td></tr></table></figure><p>在这个过程中，会持有锁。</p><h2 id="如果没有定义–no-drop-old-table，清理以上过程中的old表、创建的触发器。"><a href="#如果没有定义–no-drop-old-table，清理以上过程中的old表、创建的触发器。" class="headerlink" title="如果没有定义–no-drop-old-table，清理以上过程中的old表、创建的触发器。"></a>如果没有定义–no-drop-old-table，清理以上过程中的old表、创建的触发器。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `<span class="built_in">test</span>`.`_p_test_old`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_del`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_upd`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_ins`</span><br></pre></td></tr></table></figure><h1 id="pt-online-schema-change-用法及核心参数"><a href="#pt-online-schema-change-用法及核心参数" class="headerlink" title="pt-online-schema-change 用法及核心参数"></a>pt-online-schema-change 用法及核心参数</h1><p>–alter-foreign-keys-method<br>如何把外键引用到新表？需要特殊处理带有外键约束的表，以保证它们可以应用到新表。当重命名表的时候，外键关系会带到重命名后的表上。该工具有两种方法，可以自动找到子表，并修改约束关系。</p><p>–[no]check-replication-filters<br>默认yes，如果工具检测到服务器选项中有任何复制相关的筛选，如指定binlog_ignore_db和replicate_do_db此类。发现有这样的筛选，工具会报错且退出。因为如果更新的表Master上存在，而Slave上不存在，会导致复制的失败。使用 –no-check-replication-filters选项来禁用该检查。</p><p>–max-load<br>默认为Threads_running=25。每个chunk拷贝完后，会检查SHOW GLOBAL STATUS的内容，检查指标是否超过了指定的阈值。如果超过，则先暂停。这里可以用逗号分隔，指定多个条件，每个条件格式：status指标=MAX_VALUE或者status指标:MAX_VALUE。如果不指定MAX_VALUE，那么工具会这只其为当前值的120%。</p><p>–max-lag<br>默认1s。每个chunk拷贝完成后，会查看所有复制Slave的延迟情况（Seconds_Behind_Master）。要是延迟大于该值，则暂停复制数据，直到所有从的滞后小于这个值。–check-interval 配合使用，指定出现从库滞后超过 max-lag，则该工具将睡眠多长时间，默认1s，再检查。如–max-lag=5 –check-interval=2</p><p>–chunk-time<br>在chunk-time执行的时间内，动态调整chunk-size的大小，以适应服务器性能的变化，该参数设置为0。或者指定chunk-size，都可以禁止动态调整。</p><p>–chunk-size<br>指定块的大小，默认是1000行，可以添加k,M,G后缀。这个块的大小要尽量与 –chunk-time匹配，如果明确指定这个选项，那么每个块就会指定行数的大小。</p><p>–dry-run<br>创建和修改新表，但不会创建触发器、复制数据、和替换原表。并不真正执行，可以看到生成的执行语句，了解其执行步骤与细节。 –dry-run 与 –execute 必须指定一个，二者相互排斥。和–print配合最佳。</p><h1 id="pt-online-schema-change-实战"><a href="#pt-online-schema-change-实战" class="headerlink" title="pt-online-schema-change 实战"></a>pt-online-schema-change 实战</h1><h2 id="简单的修改字段和增删索引"><a href="#简单的修改字段和增删索引" class="headerlink" title="简单的修改字段和增删索引"></a>简单的修改字段和增删索引</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"ADD COLUMN channal tinyint(4) UNSIGNED NOT NULL;"</span> \</span><br><span class="line">--max-lag=1 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><h2 id="修改主键或唯一索引操作"><a href="#修改主键或唯一索引操作" class="headerlink" title="修改主键或唯一索引操作"></a>修改主键或唯一索引操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增主键ID' FIRST, DROP PRIMARY KEY, </span></span><br><span class="line"><span class="string">ADD PRIMARY KEY (id), ADD UNIQUE INDEX uniq_ui_ct(user_id);"</span> \</span><br><span class="line">--no-check-unique-key-change --no-check-alter --max-lag=1 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><h2 id="重定义分区表操作"><a href="#重定义分区表操作" class="headerlink" title="重定义分区表操作"></a>重定义分区表操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"PARTITION BY RANGE COLUMNS(create_time)(</span></span><br><span class="line"><span class="string"> PARTITION p01 VALUES LESS THAN ('2017-01-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p02 VALUES LESS THAN ('2017-02-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p03 VALUES LESS THAN ('2017-03-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p04 VALUES LESS THAN ('2017-04-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p00 VALUES LESS THAN (MAXVALUE));"</span> \</span><br><span class="line">--max-lag=1 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><h2 id="存在主外键关联表字段操作"><a href="#存在主外键关联表字段操作" class="headerlink" title="存在主外键关联表字段操作"></a>存在主外键关联表字段操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">""</span> \</span><br><span class="line">--alter-foreign-keys-method=rebuild_constraints --max-lag=1 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><h2 id="主从环境下的字段操作"><a href="#主从环境下的字段操作" class="headerlink" title="主从环境下的字段操作"></a>主从环境下的字段操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">""</span> \</span><br><span class="line">--no-check-replication-filters --max-lag=1 --max-lag=2 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><p>参考文档：<br>pt-online-schema-change在线修改表结构：<a href="http://www.ywnds.com/?p=4442" target="_blank" rel="noopener">http://www.ywnds.com/?p=4442</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;pt-online-schema-change-背景&quot;&gt;&lt;a href=&quot;#pt-online-schema-change-背景&quot; class=&quot;headerlink&quot; title=&quot;pt-online-schema-change
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="pt-tools" scheme="http://yoursite.com/tags/pt-tools/"/>
    
  </entry>
  
  <entry>
    <title>pt-online-schema-change 实现 MySQL 在线重定义普通表转分区表</title>
    <link href="http://yoursite.com/2018/04/18/MySQL/MySQL_Partition/"/>
    <id>http://yoursite.com/2018/04/18/MySQL/MySQL_Partition/</id>
    <published>2018-04-18T11:48:56.124Z</published>
    <updated>2018-04-18T21:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p><h1 id="表分区缘由"><a href="#表分区缘由" class="headerlink" title="表分区缘由"></a>表分区缘由</h1><p>1、表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他都是历史数据<br>2、分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备<br>3、优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时在涉及sum()和count()这类聚合函数的查询时，可以在每个分区上面并行处理，最终只需要汇总所有分区得到的结果。<br>4、如果需要，还可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好<br>5、分区表的数据更容易维护，如：想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作</p><h1 id="分区表设计"><a href="#分区表设计" class="headerlink" title="分区表设计"></a>分区表设计</h1><p>对于生产中一个普通字符串主键的大表，我们该如何在不影响前端业务的情况下，将其改造成分区表。例如普通表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"p_test"</span> (</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"user_id"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>我们该如何设计这种表的分区表，来隔离冷热数据，MySQL 5.7 版本后COLUMNS分区支持对整形、字符串、日期和时间撮等各类型数据分区，分区跨度可随数据规模定义，可设计为按月、按日分区或者按小时分区。具体分区表设计如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"p_test"</span> (</span><br><span class="line">  <span class="string">"id"</span> int(20) NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">"user_id"</span> varchar(32) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_ui_ct"</span> (<span class="string">"user_id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">/*!50500 PARTITION BY RANGE COLUMNS(create_time)</span><br><span class="line">(PARTITION p01 VALUES LESS THAN (<span class="string">'2018-01-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p02 VALUES LESS THAN (<span class="string">'2018-02-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p03 VALUES LESS THAN (<span class="string">'2018-03-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p04 VALUES LESS THAN (<span class="string">'2018-04-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p00 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */;</span><br></pre></td></tr></table></figure></p><p>看到 PRIMARY KEY (“id”,”create_time”),UNIQUE KEY “uniq_ui_ct” (“user_id”,”create_time”)也许会疑惑，为什么要对自增主键和唯一索引添加create_time的复合主键和联合唯一索引，这是因为range的分区要求唯一索引类必须和分区键搭配构成分区表的唯一索引，不然会报错误：1503 - A PRIMARY KEY/UNIQUE INDEX must include all columns in the table’s partitioning function。<br>还有一个原因，就是修改主键影响最大的就是 DELETE 触发器，新表上的主键字段在旧表上不存在，无法根据主键条件触发删除新表数据。而对于INSERT,UPDATE的触发器，依然是 REPLACE INTO语法，因为它采用的是先插入，如果违反主键或唯一约束，则根据主键或意义约束删除这条数据，再执行插入。所以如果使用pt-osc去修改删除主键，务必同时添加原主键为 UNIQUE KEY，否则很有可能导致性能问题。</p><h1 id="pt-osc-实现在线重定义分区表原理"><a href="#pt-osc-实现在线重定义分区表原理" class="headerlink" title="pt-osc 实现在线重定义分区表原理"></a>pt-osc 实现在线重定义分区表原理</h1><p>在实现过程中，我也试图只通过一次 pt-osc 过程来实现在线重定义分区表的过程，但是 MySQL DDL语法并不支持同时对分区和普通DDL操作，实现过程如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:<span class="built_in">test</span>&gt;ALTER TABLE <span class="string">"p_test"</span> </span><br><span class="line">    -&gt; ADD COLUMN <span class="string">"id"</span> bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST,</span><br><span class="line">    -&gt; DROP PRIMARY KEY,</span><br><span class="line">    -&gt; ADD PRIMARY KEY (<span class="string">"id"</span>, <span class="string">"create_time"</span>),</span><br><span class="line">    -&gt; ADD UNIQUE INDEX <span class="string">"uniq_ui_ct"</span>(<span class="string">"user_id"</span>, <span class="string">"create_time"</span>);</span><br><span class="line">Query OK, 0 rows affected (0.33 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">root@localhost:<span class="built_in">test</span>&gt;Alter table <span class="string">"p_test"</span> PARTITION BY RANGE COLUMNS(create_time)</span><br><span class="line">    -&gt; (PARTITION p01 VALUES LESS THAN (<span class="string">'2017-01-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p02 VALUES LESS THAN (<span class="string">'2017-02-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p03 VALUES LESS THAN (<span class="string">'2017-03-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p04 VALUES LESS THAN (<span class="string">'2017-04-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p00 VALUES LESS THAN (MAXVALUE));</span><br><span class="line">Query OK, 0 rows affected (1.49 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">root@localhost:<span class="built_in">test</span>&gt;ALTER TABLE <span class="string">"p_test"</span> </span><br><span class="line">    -&gt; ADD COLUMN <span class="string">"id"</span> bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST,</span><br><span class="line">    -&gt; DROP PRIMARY KEY,</span><br><span class="line">    -&gt; ADD PRIMARY KEY (<span class="string">"id"</span>, <span class="string">"create_time"</span>),</span><br><span class="line">    -&gt; ADD UNIQUE INDEX <span class="string">"uniq_ui_ct"</span>(<span class="string">"user_id"</span>, <span class="string">"create_time"</span>),</span><br><span class="line">    -&gt; PARTITION BY RANGE COLUMNS(create_time)</span><br><span class="line">    -&gt; (PARTITION p01 VALUES LESS THAN (<span class="string">'2017-01-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p02 VALUES LESS THAN (<span class="string">'2017-02-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p03 VALUES LESS THAN (<span class="string">'2017-03-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p04 VALUES LESS THAN (<span class="string">'2017-04-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p00 VALUES LESS THAN (MAXVALUE));</span><br><span class="line">ERROR 1064 (42000): You have an error <span class="keyword">in</span> your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">'PARTITION BY RANGE COLUMNS(create_time)</span></span><br><span class="line"><span class="string">(PARTITION p01 VALUES LESS THAN ('</span>2017-0<span class="string">' at line 6</span></span><br></pre></td></tr></table></figure></p><p>为了便于观察和理解 pt-osc 实现过程在线重定义过程，我们通过 –no-drop-old-table 保留原普通表结构和数据</p><h2 id="pt-osc-修改表主键"><a href="#pt-osc-修改表主键" class="headerlink" title="pt-osc 修改表主键"></a>pt-osc 修改表主键</h2><p>pt-osc 实现修改主键过程和原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增主键ID' FIRST, DROP PRIMARY KEY, </span></span><br><span class="line"><span class="string">ADD PRIMARY KEY (id, create_time), ADD UNIQUE INDEX uniq_ui_ct(user_id, create_time);"</span> \</span><br><span class="line">--no-check-unique-key-change --no-check-alter --no-drop-old-table --<span class="built_in">print</span> --dry-run</span><br><span class="line"></span><br><span class="line">Operation, tries, <span class="built_in">wait</span>:</span><br><span class="line">  analyze_table, 10, 1</span><br><span class="line">  copy_rows, 10, 0.25</span><br><span class="line">  create_triggers, 10, 1</span><br><span class="line">  drop_triggers, 10, 1</span><br><span class="line">  swap_tables, 10, 1</span><br><span class="line">  update_foreign_keys, 10, 1</span><br><span class="line">Starting a dry run.  `<span class="built_in">test</span>`.`p_test` will not be altered.  Specify --execute instead of --dry-run to alter the table.</span><br><span class="line">Creating new table...</span><br><span class="line">CREATE TABLE `<span class="built_in">test</span>`.`_p_test_new` (</span><br><span class="line">  `user_id` varchar(20) NOT NULL,</span><br><span class="line">  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">Created new table test._p_test_new OK.</span><br><span class="line">Altering new table...</span><br><span class="line">ALTER TABLE `<span class="built_in">test</span>`.`_p_test_new` ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST, DROP PRIMARY KEY, </span><br><span class="line">ADD PRIMARY KEY (id, create_time), ADD UNIQUE INDEX uniq_ui_ct(user_id, create_time);</span><br><span class="line">Altered `<span class="built_in">test</span>`.`_p_test_new` OK.</span><br><span class="line">Using original table index PRIMARY <span class="keyword">for</span> the DELETE trigger instead of new table index PRIMARY because the new table index uses column id <span class="built_in">which</span> does not exist <span class="keyword">in</span> the original table.</span><br><span class="line">Not creating triggers because this is a dry run.</span><br><span class="line">Not copying rows because this is a dry run.</span><br><span class="line">INSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` LOCK IN SHARE MODE /*pt-online-schema-change 10134 copy table*/</span><br><span class="line">Not swapping tables because this is a dry run.</span><br><span class="line">Not dropping old table because this is a dry run.</span><br><span class="line">Not dropping triggers because this is a dry run.</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_del`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_upd`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_ins`</span><br><span class="line">2018-04-18T15:10:26 Dropping new table...</span><br><span class="line">DROP TABLE IF EXISTS `<span class="built_in">test</span>`.`_p_test_new`;</span><br><span class="line">2018-04-18T15:10:26 Dropped new table OK.</span><br><span class="line">Dry run complete.  `<span class="built_in">test</span>`.`p_test` was not altered.</span><br></pre></td></tr></table></figure></p><p>操作、实现过程修改主键如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增主键ID' FIRST, DROP PRIMARY KEY, </span></span><br><span class="line"><span class="string">ADD PRIMARY KEY (id, create_time), ADD UNIQUE INDEX uniq_ui_ct(user_id, create_time);"</span> \</span><br><span class="line">--no-check-unique-key-change --no-check-alter --no-drop-old-table --max-lag=1 --execute</span><br></pre></td></tr></table></figure></p><p>对比 _p_test_new 和 p_test 表结构，符合预期，表主键已经由 varchar 字符串主键修改为自增和 datetime 类型联合主键类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"_p_test_old"</span> (</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"user_id"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">"p_test"</span> (</span><br><span class="line">  <span class="string">"id"</span> bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_ui_ct"</span> (<span class="string">"user_id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><h2 id="pt-osc-在线重定义分区表"><a href="#pt-osc-在线重定义分区表" class="headerlink" title="pt-osc 在线重定义分区表"></a>pt-osc 在线重定义分区表</h2><p>在线重定义普通表转分区表过程和原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"PARTITION BY RANGE COLUMNS(create_time)(</span></span><br><span class="line"><span class="string"> PARTITION p01 VALUES LESS THAN ('2017-01-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p02 VALUES LESS THAN ('2017-02-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p03 VALUES LESS THAN ('2017-03-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p04 VALUES LESS THAN ('2017-04-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p00 VALUES LESS THAN (MAXVALUE));"</span> \</span><br><span class="line">--no-drop-old-table --max-lag=1 --<span class="built_in">print</span> --dry-run</span><br><span class="line"></span><br><span class="line">Operation, tries, <span class="built_in">wait</span>:</span><br><span class="line">  analyze_table, 10, 1</span><br><span class="line">  copy_rows, 10, 0.25</span><br><span class="line">  create_triggers, 10, 1</span><br><span class="line">  drop_triggers, 10, 1</span><br><span class="line">  swap_tables, 10, 1</span><br><span class="line">  update_foreign_keys, 10, 1</span><br><span class="line">Starting a dry run.  `<span class="built_in">test</span>`.`p_test` will not be altered.  Specify --execute instead of --dry-run to alter the table.</span><br><span class="line">Creating new table...</span><br><span class="line">CREATE TABLE `<span class="built_in">test</span>`.`_p_test_new` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  `user_id` varchar(20) NOT NULL,</span><br><span class="line">  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (`id`,`create_time`),</span><br><span class="line">  UNIQUE KEY `uniq_ui_ct` (`user_id`,`create_time`),</span><br><span class="line">  KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2048 DEFAULT CHARSET=utf8</span><br><span class="line">Created new table test._p_test_new OK.</span><br><span class="line">Altering new table...</span><br><span class="line">ALTER TABLE `<span class="built_in">test</span>`.`_p_test_new` PARTITION BY RANGE COLUMNS(create_time)(</span><br><span class="line"> PARTITION p01 VALUES LESS THAN (<span class="string">'2017-01-01 00:00:00'</span>),</span><br><span class="line"> PARTITION p02 VALUES LESS THAN (<span class="string">'2017-02-01 00:00:00'</span>),</span><br><span class="line"> PARTITION p03 VALUES LESS THAN (<span class="string">'2017-03-01 00:00:00'</span>),</span><br><span class="line"> PARTITION p04 VALUES LESS THAN (<span class="string">'2017-04-01 00:00:00'</span>),</span><br><span class="line"> PARTITION p00 VALUES LESS THAN (MAXVALUE));</span><br><span class="line">Altered `<span class="built_in">test</span>`.`_p_test_new` OK.</span><br><span class="line">Not creating triggers because this is a dry run.</span><br><span class="line">Not copying rows because this is a dry run.</span><br><span class="line">INSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`id`, `user_id`, `create_time`) SELECT `id`, `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` LOCK IN SHARE MODE /*pt-online-schema-change 5211 copy table*/</span><br><span class="line">Not swapping tables because this is a dry run.</span><br><span class="line">Not dropping old table because --no-drop-old-table was specified.</span><br><span class="line">Not dropping triggers because this is a dry run.</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_del`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_upd`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_ins`</span><br><span class="line">2018-04-18T10:23:47 Dropping new table...</span><br><span class="line">DROP TABLE IF EXISTS `<span class="built_in">test</span>`.`_p_test_new`;</span><br><span class="line">2018-04-18T10:23:47 Dropped new table OK.</span><br><span class="line">Dry run complete.  `<span class="built_in">test</span>`.`p_test` was not altered.</span><br></pre></td></tr></table></figure></p><p>实现在线重定义分区表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"PARTITION BY RANGE COLUMNS(create_time)(</span></span><br><span class="line"><span class="string"> PARTITION p01 VALUES LESS THAN ('2017-01-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p02 VALUES LESS THAN ('2017-02-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p03 VALUES LESS THAN ('2017-03-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p04 VALUES LESS THAN ('2017-04-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p00 VALUES LESS THAN (MAXVALUE));"</span> \</span><br><span class="line">--no-drop-old-table --max-lag=1 --execute</span><br></pre></td></tr></table></figure></p><p>对比 __p_test_new 和 p_test 表结构，符合预期结果，表被定义为分区表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"p_test"</span> (</span><br><span class="line">  <span class="string">"id"</span> bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_ui_ct"</span> (<span class="string">"user_id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2048 DEFAULT CHARSET=utf8</span><br><span class="line">/*!50500 PARTITION BY RANGE  COLUMNS(create_time)</span><br><span class="line">(PARTITION p01 VALUES LESS THAN (<span class="string">'2017-01-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p02 VALUES LESS THAN (<span class="string">'2017-02-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p03 VALUES LESS THAN (<span class="string">'2017-03-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p04 VALUES LESS THAN (<span class="string">'2017-04-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p00 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */;</span><br><span class="line"></span><br><span class="line"> CREATE TABLE <span class="string">"__p_test_old"</span> (</span><br><span class="line">  <span class="string">"id"</span> bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_ui_ct"</span> (<span class="string">"user_id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2048 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>总结pt-osc实现在线重定义普通标转分区表原理：<br>pt-osc 首先创建一个不可见的临时表，然后对临时表修改表结构或者重定义分区表，再后创建更新、删除、插入3个触发器，按一个chunk-size大小拷贝数据，拷贝过程中对chunk块持有s锁，同时对新增的insert、update、delete操作通过触发器写入临时表，因为有唯一索引 uniq_ui_ct 避免了 update 和 delete 操作导致可能对临时表的全表扫描，复制操作完成后，analyze 新表，重新 rename 表名，删除普通表、触发器，锁只会存在对每一个 chunk 复制和 rename 表名的时候。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;MySQL
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="pt-tools" scheme="http://yoursite.com/tags/pt-tools/"/>
    
      <category term="MySQL 优化" scheme="http://yoursite.com/tags/MySQL-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
