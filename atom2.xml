<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cailiang&#39;s Blog</title>
  
  <subtitle>飞翔的菜鸟</subtitle>
  <link href="/atom2.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-15T01:25:32.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>cai182081</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 索引原理详解</title>
    <link href="http://yoursite.com/2018/05/03/MySQL/MySQL_Lock/"/>
    <id>http://yoursite.com/2018/05/03/MySQL/MySQL_Lock/</id>
    <published>2018-05-03T05:58:32.431Z</published>
    <updated>2017-10-15T01:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-索引实现"><a href="#MySQL-索引实现" class="headerlink" title="MySQL 索引实现"></a>MySQL 索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎(MySQL数据库MyISAM和InnoDB存储引擎的比较)的索引实现方式。MyISAM属于对堆组织表，InnoDB属于索引组织表。</p><h2 id="MySQL-索引类型"><a href="#MySQL-索引类型" class="headerlink" title="MySQL 索引类型"></a>MySQL 索引类型</h2><h3 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h3><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列的值计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码不一样，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。<br>Hash 索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。hash相当于把key通过hash函数计算，得到key的hash值,再用这个hash值做指针，查找hash表中是否存在key，如果存在就返回 key所对应的value，选定一个好的hash函数很重要，好的hash函数可以使计算出的hash值分布均匀，降低冲突，只有冲突减小了，才会降低 hash表的查找时间Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。在MySQL中，只有HEAP/MEMORY引擎表才能显式支持哈希索引（NDB也支持，但这个不常用），而且支持非唯一的哈希索引。在数据库世界里是比较与众不同，如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。InnoDB引擎的自适应哈希索引（adaptive hash index）不在此列。InnoDB具有一个特别的特性被称为自适应性hash索引。InnoDB发现比较频繁访问的索引值，会为其在B-Tree索引之上建立Hash索引，这使得B-Tree索引具有一定的hash特性，这个特性是自动的，无法控制和配置,只能开启和关闭此特性。<br>虽然 hash 索引效率高，但是 hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a、<span class="built_in">hash</span> 索引仅仅能满足=，&lt;=&gt;，IN，IS NULL或者IS NOT NULL查询，不能使用范围查询。</span><br><span class="line">    由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</span><br><span class="line">b、Hash 索引无法被用来避免数据的排序操作。</span><br><span class="line">    由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</span><br><span class="line">c、Hash 索引不能利用部分索引键查询。</span><br><span class="line">    对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</span><br><span class="line">d、Hash 索引在任何时候都不能避免表扫描。</span><br><span class="line">    Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</span><br><span class="line">e、Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</span><br><span class="line">    对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下</span><br></pre></td></tr></table></figure></p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="R-树索引"><a href="#R-树索引" class="headerlink" title="R 树索引"></a>R 树索引</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Fulltext-索引"><a href="#Fulltext-索引" class="headerlink" title="Fulltext 索引"></a>Fulltext 索引</h3><p>MySQL 5.6.4版本之前只有MyISAM引擎支持fulltext全文索引，InnoDB在5.6.4版本以后就开始支持fulltext全文索引，从MySQL 5.7.6开始，MySQL内置了ngram全文检索插件，开始支持中文全文索引，并且对MyISAM和InnoDB引擎有效。</p><h2 id="InnoDB和MyISAM引擎索引实现原理"><a href="#InnoDB和MyISAM引擎索引实现原理" class="headerlink" title="InnoDB和MyISAM引擎索引实现原理"></a>InnoDB和MyISAM引擎索引实现原理</h2><h3 id="MyISAM-与-InnoDB-区别"><a href="#MyISAM-与-InnoDB-区别" class="headerlink" title="MyISAM 与 InnoDB 区别"></a>MyISAM 与 InnoDB 区别</h3><p>  MyISAM中的表是以堆表的方式进行存储，堆表没有主键，因此没有聚集索引，辅助索引叶节点不是返回主键值，而是返回行标志符（ROWID），通过ROWID再去查找相应的行。很显然，对于堆表来说，通过辅助索引访问更快(IO更少)，但是如果在OLTP应用下，表中数据经常被修改，辅助索引中的ROWID可能需要经常更新，如果更新影响到物理地址的更改，这种开销比索引组织表要大得多。因此，索引组织表还是堆表，这取决于你的应用，如果你的应用是OLAP，数据更新很少，堆表更好一些。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InnoDB支持事务，MyisAM不支持；</span><br><span class="line">MyisAM顺序储存数据，索引叶子节点保存对应数据行地址，辅助索引很主键索引相差无几；InnoDB主键节点同时保存数据行，其他辅助索引保存的是主键索引的值；</span><br><span class="line">MyisAM键值分离，索引载入内存（key_buffer_size），数据缓存依赖操作系统；InnoDB键值一起保存，索引与数据一起载入InnoDB缓冲池；MyisAM主键（唯一）索引按升序来存数据，InnoDB则不一定</span><br><span class="line">MyisAM索引的基数值（Cardinality，show index 命令可以看见）是精确的，InnoDB则是估计值。这里涉及到信息统计的知识，MyisAM统计信息是保存磁盘中，在alter表或Analyze table操作更新此信息，而InnoDB则是在表第一次打开的时候估计值保存在缓存区内；</span><br><span class="line">MyisAM处理字符串索引时用增量保存的方式，如第一个索引是‘preform’，第二个是‘preformence’，则第二个保存是‘7，ance’，这个明显的好处是缩短索引，但是缺陷就是不支持倒序提取索引，必须顺序遍历获取索引</span><br></pre></td></tr></table></figure></p><h3 id="MyISAM-索引实现原理"><a href="#MyISAM-索引实现原理" class="headerlink" title="MyISAM 索引实现原理"></a>MyISAM 索引实现原理</h3><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。对于非聚簇索引表来说，表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的地址。对于聚簇索引表来说，表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。</p><h3 id="InnoDB-索引实现原理"><a href="#InnoDB-索引实现原理" class="headerlink" title="InnoDB 索引实现原理"></a>InnoDB 索引实现原理</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>聚集索引并不是一种单独的索引类型，而是一种数据存储方式（不是数据结构，而是存储结构），具体细节依赖于其实现方式，但InnoDB的聚集索引实际上是在同一个结构中保存了B-Tree索引和数据行。<br>当表有索引时，它的数据行实际上存放在索引的叶子页中，属于聚集表示数据行和相邻的键值紧凑地存储在一起，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚集索引。因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚集索引。下面主要介绍InnoDB，但下面讨论的原理对于任何支持聚集索引（TokuDB可以有多个聚集索引）的引擎都适用：<br>叶子页包含了行的全部数据，但是节点页只包含了索引列（或者可以说非叶子节点的节点页包含的是索引值的索引，因为这些节点页包含的值是从索引列中提取出来的）。<br>InnoDB将通过主键聚集数据，如果没有定义主键，InnoDB会选择第一个非空的唯一索引代替，如果没有非空唯一索引，InnoDB会隐式定义一个6字节的rowid主键来作为聚集索引。InnoDB只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远。<br>要注意：聚集主键可能对性能有帮助，但也可能导致严重的性能问题，尤其是将表的存储引擎从InnoDB转换成其他引擎的时候。<br>聚集的数据有一些重要的优点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A：可以把相关数据保存在一起，如：实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户全部邮件，如果没有使用聚集索引，则每封邮件都可能导致一次磁盘IO</span><br><span class="line">B：数据访问更快，聚集索引将索引和数据保存在同一个B-Tree中，因此从聚集索引中获取数据通常比在非聚集索引中查找要快</span><br><span class="line">C：使用覆盖索引扫描的查询可以直接使用页节点中的主键值</span><br></pre></td></tr></table></figure></p><p>聚集索引的缺点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A：聚集数据最大限度地提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚集索引也没有什么优势了</span><br><span class="line">B：插入速度严重依赖于插入顺序，按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式，但如果不是按照主键顺序加载数据，那么在加载完成后最好使用optimize table命令重新组织一下表</span><br><span class="line">C：更新聚集索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</span><br><span class="line">D：基于聚集索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题，当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，页分裂会导致表占用更多的磁盘空间</span><br><span class="line">E：聚集索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</span><br><span class="line">F：二级索引可能比想象的更大，因为在二级索引的叶子节点包含了引用行的主键列。</span><br><span class="line">G：二级索引访问需要两次索引查找，而不是一次</span><br></pre></td></tr></table></figure></p><h2 id="InnoDB的主键选择与优化"><a href="#InnoDB的主键选择与优化" class="headerlink" title="InnoDB的主键选择与优化"></a>InnoDB的主键选择与优化</h2><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引，如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。<br>数据记录本身被存于主键索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页；如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。<br>综上总结，如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的，也就是下面这几种情况的存取效率最高：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A、使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致；</span><br><span class="line">B、该表不指定自增列做主键，同时也没有可以被选为主键的唯一索引(上面的条件)，这时候InnoDB会选择内置的ROWID作为主键，写入顺序和ROWID增长顺序一致；</span><br><span class="line">除此以外，如果一个InnoDB表又没有显示主键，又有可以被选择为主键的唯一索引，但该唯一索引可能不是递增关系时(例如字符串、UUID、多字段联合唯一索引的情况)，该表的存取效率就会比较差。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;MySQL-索引实现&quot;&gt;&lt;a href=&quot;#MySQL-索引实现&quot; class=&quot;headerlink&quot; title=&quot;MySQL 索引实现&quot;&gt;&lt;/a&gt;MySQL
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库优化" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>函数、存储过程和试图定义者变更脚本</title>
    <link href="http://yoursite.com/2018/04/22/MySQL/MySQL_Change_Definder/"/>
    <id>http://yoursite.com/2018/04/22/MySQL/MySQL_Change_Definder/</id>
    <published>2018-04-21T23:08:30.964Z</published>
    <updated>2018-04-21T04:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 MySQL 数据库日常迁移过程中，由于操作的不规范性，常常因为函数、存储过程和视图定义者的缺失，导致存储过程、函数和视图失效，或者mysqldump逻辑备份无法备份和恢复。如果涉及的存储过程、函数和视图较多，一个一个的修改可能耗时和人为错误，所以特别设计函数批量修改存储过程、函数和视图的定义者，以减少运维维护量。这里默认将所有的定义者修改为‘root‘@’localhost’。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //  </span><br><span class="line">CREATE DEFINER = CURRENT_USER () PROCEDURE p_change_definer (</span><br><span class="line">`pr_database_name` VARCHAR (500), -- 数据库名称</span><br><span class="line">`pr_definer_name` VARCHAR (500), -- 定义者名称，默认 root</span><br><span class="line">`pr_definer_ip_name` VARCHAR (500) -- 定义者绑定ip，默认为 localhost</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">DECLARE drop_view_ varchar(500);</span><br><span class="line">DECLARE create_view_ varchar(15500);</span><br><span class="line">DECLARE DATABASE_NAME VARCHAR(500);</span><br><span class="line">DECLARE DEFINER_NAME VARCHAR(500) DEFAULT <span class="string">'root'</span>;</span><br><span class="line">DECLARE DEFINER_IP_NAME VARCHAR (500) DEFAULT <span class="string">'localhost'</span>;</span><br><span class="line">DECLARE flag boolean DEFAULT 1;</span><br><span class="line">DECLARE cur CURSOR FOR SELECT drop_view,create_view FROM sql_value;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NOT FOUND SET flag = 0;</span><br><span class="line"></span><br><span class="line">DROP TEMPORARY TABLE IF EXISTS sql_value; </span><br><span class="line">CREATE TEMPORARY TABLE sql_value(drop_view varchar(500),create_view varchar(15500));</span><br><span class="line"></span><br><span class="line">SET DATABASE_NAME = TRIM(pr_database_name);</span><br><span class="line"></span><br><span class="line">IF pr_definer_name IS NOT NULL AND LENGTH(pr_definer_name) &gt; 0 THEN</span><br><span class="line">SET DEFINER_NAME = TRIM(pr_definer_name);</span><br><span class="line">END IF;</span><br><span class="line">IF pr_definer_ip_name IS NOT NULL AND LENGTH(pr_definer_ip_name) &gt; 0 THEN</span><br><span class="line">SET DEFINER_IP_NAME = pr_definer_ip_name;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">-- 组装修改视图定义者语句</span><br><span class="line">IF DATABASE_NAME IS NOT NULL AND LENGTH(DATABASE_NAME) &gt;0 THEN</span><br><span class="line"> INSERT INTO sql_value</span><br><span class="line">  (drop_view, create_view)</span><br><span class="line">  SELECT GROUP_CONCAT(<span class="string">'DROP VIEW IF EXISTS '</span>, TABLE_SCHEMA, <span class="string">'.'</span>, TABLE_NAME, <span class="string">';'</span>),</span><br><span class="line">         GROUP_CONCAT(<span class="string">'CREATE ALGORITHM = UNDEFINED DEFINER = `'</span>, DEFINER_NAME, <span class="string">'`@`'</span>, DEFINER_IP_NAME, <span class="string">'` SQL SECURITY DEFINER VIEW `'</span>,</span><br><span class="line"> TABLE_SCHEMA, <span class="string">'`.`'</span>, TABLE_NAME, <span class="string">'` as '</span>, VIEW_DEFINITION, <span class="string">';'</span> SEPARATOR <span class="string">''</span>)</span><br><span class="line">    FROM information_schema.VIEWS</span><br><span class="line">   WHERE TABLE_SCHEMA = DATABASE_NAME</span><br><span class="line">   GROUP BY TABLE_NAME;</span><br><span class="line"></span><br><span class="line">-- 执行修改视图定义者</span><br><span class="line">OPEN cur;</span><br><span class="line"></span><br><span class="line">rep:LOOP</span><br><span class="line">  FETCH cur INTO drop_view_,create_view_;</span><br><span class="line">  <span class="built_in">set</span> @drop_view_ = drop_view_;</span><br><span class="line">  <span class="built_in">set</span> @create_view_ = create_view_;</span><br><span class="line">  IF flag = 0 THEN </span><br><span class="line">    LEAVE rep;</span><br><span class="line">  END IF;</span><br><span class="line"></span><br><span class="line">   PREPARE stmt FROM @drop_view_;</span><br><span class="line">   EXECUTE stmt;</span><br><span class="line">   DEALLOCATE PREPARE stmt;</span><br><span class="line">   PREPARE stmt FROM @create_view_;</span><br><span class="line">   EXECUTE stmt;</span><br><span class="line">   DEALLOCATE PREPARE stmt;</span><br><span class="line">END LOOP;</span><br><span class="line"></span><br><span class="line">CLOSE cur;</span><br><span class="line"></span><br><span class="line">-- 修改存储过程定义者</span><br><span class="line">UPDATE mysql.proc <span class="built_in">set</span> DEFINER = CONCAT(DEFINER_NAME,<span class="string">'@'</span>,DEFINER_IP_NAME) WHERE db = DATABASE_NAME;</span><br><span class="line"></span><br><span class="line">ELSE</span><br><span class="line">  SELECT <span class="string">'数据库名称不允许为空'</span>;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><p>修改执行命令为 ：<br>call p_change_definer(‘database’,’user’,’ip’);<br>database –需要修改的库名<br>user     –数据库的用户<br>IP       –数据库的绑定ip</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在 MySQL
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL 日常维护" scheme="http://yoursite.com/tags/MySQL-%E6%97%A5%E5%B8%B8%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>SQL 优化之美：对一条简单 SQL 优化的理解、分析</title>
    <link href="http://yoursite.com/2018/04/21/SQL/DB_SQL_5/"/>
    <id>http://yoursite.com/2018/04/21/SQL/DB_SQL_5/</id>
    <published>2018-04-20T17:21:02.872Z</published>
    <updated>2018-04-20T18:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-SQL"><a href="#问题-SQL" class="headerlink" title="问题 SQL"></a>问题 SQL</h1><p>SQL执行时间0.8s,SQL文本如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT old_user_id, nick_name, channel, status</span><br><span class="line">  FROM user_relation</span><br><span class="line"> WHERE old_user_id IN</span><br><span class="line">       (SELECT old_user_id</span><br><span class="line">          FROM user_relation</span><br><span class="line">         WHERE old_user_id = <span class="string">'1601474800051044'</span></span><br><span class="line">            OR new_user_id = <span class="string">'1601474800051044'</span>)</span><br><span class="line">    OR new_user_id IN</span><br><span class="line">       (SELECT new_user_id</span><br><span class="line">          FROM user_relation</span><br><span class="line">         WHERE old_user_id = <span class="string">'1601474800051044'</span></span><br><span class="line">            OR new_user_id = <span class="string">'1601474800051044'</span>);</span><br></pre></td></tr></table></figure></p><p>表结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"user_relation"</span> (</span><br><span class="line">  <span class="string">"pay_organ_id"</span> varchar(50) NOT NULL,</span><br><span class="line">  <span class="string">"old_user_id"</span> varchar(32) DEFAULT NULL,</span><br><span class="line">  <span class="string">"new_user_id"</span> varchar(32) NOT NULL,</span><br><span class="line">  <span class="string">"nick_name"</span> varchar(15) DEFAULT NULL,</span><br><span class="line">  <span class="string">"channel"</span> char(1) DEFAULT NULL,</span><br><span class="line">  <span class="string">"status"</span> char(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (<span class="string">"pay_organ_id"</span>,<span class="string">"new_user_id"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_new_user_id"</span> (<span class="string">"new_user_id"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_old_user_id"</span> (<span class="string">"old_user_id"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>执行计划如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    id  select_type  table          partitions  <span class="built_in">type</span>         possible_keys                      key                                key_len  ref        rows  filtered  Extra                                                        </span><br><span class="line">------  -----------  -------------  ----------  -----------  ---------------------------------  ---------------------------------  -------  ------  -------  --------  -------------------------------------------------------------</span><br><span class="line">     1  PRIMARY      user_relation  (NULL)      ALL          (NULL)                             (NULL)                             (NULL)   (NULL)  1124585    100.00  Using <span class="built_in">where</span>                                                  </span><br><span class="line">     3  SUBQUERY     user_relation  (NULL)      index_merge  uniq_new_user_id,uniq_old_user_id  uniq_old_user_id,uniq_new_user_id  99,98    (NULL)        2    100.00  Using union(uniq_old_user_id,uniq_new_user_id); Using <span class="built_in">where</span>  </span><br><span class="line">     2  SUBQUERY     user_relation  (NULL)      index_merge  uniq_new_user_id,uniq_old_user_id  uniq_old_user_id,uniq_new_user_id  99,98    (NULL)        2    100.00  Using union(uniq_old_user_id,uniq_new_user_id); Using <span class="built_in">where</span></span><br></pre></td></tr></table></figure></p><h1 id="SQL-性能瓶颈分析"><a href="#SQL-性能瓶颈分析" class="headerlink" title="SQL 性能瓶颈分析"></a>SQL 性能瓶颈分析</h1><p>从执行计划中可得知，MySQL优化器先后分别运算两个子查询后，再执行主查询，而主查询是经全表扫描后得到数据，主查询无法将谓词下推到子查询，通过索引检索，分析</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;问题-SQL&quot;&gt;&lt;a href=&quot;#问题-SQL&quot; class=&quot;headerlink&quot; title=&quot;问题 SQL&quot;&gt;&lt;/a&gt;问题 SQL&lt;/h1&gt;&lt;p&gt;SQL执行时间0.8s,SQL文本如下：&lt;br&gt;&lt;figure class=&quot;highlight
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="数据库优化" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
      <category term="SQL 优化" scheme="http://yoursite.com/tags/SQL-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>pt-online-schema-change 实现原理及其用法</title>
    <link href="http://yoursite.com/2018/04/18/MySQL/MySQL_PT_OSC/"/>
    <id>http://yoursite.com/2018/04/18/MySQL/MySQL_PT_OSC/</id>
    <published>2018-04-18T11:48:56.126Z</published>
    <updated>2018-04-19T05:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pt-online-schema-change-背景"><a href="#pt-online-schema-change-背景" class="headerlink" title="pt-online-schema-change 背景"></a>pt-online-schema-change 背景</h1><p>pt-online-schema-change 用于MySQL的在线DDL操作</p><h1 id="pt-online-schema-change-使用限制"><a href="#pt-online-schema-change-使用限制" class="headerlink" title="pt-online-schema-change 使用限制"></a>pt-online-schema-change 使用限制</h1><p>1、原表必须存在主键 PRIMARY KEY 或者 UNIQUE KEY<br>2、原表不能存在触发器<br>3、外键的处理需要指定 alter-foreign-keys-method 参数<br>4、剩余的数据盘空间至少为原表大小的一倍</p><h1 id="pt-online-schema-change-实现原理"><a href="#pt-online-schema-change-实现原理" class="headerlink" title="pt-online-schema-change 实现原理"></a>pt-online-schema-change 实现原理</h1><p>pt-online-schema-change 修改表结构过程 general_log 日志内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">Connectroot@localhost on <span class="built_in">test</span> using Socket</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'innodb\_lock_wait_timeout'</span></span><br><span class="line">QuerySET SESSION innodb_lock_wait_timeout=1</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'lock\_wait_timeout'</span></span><br><span class="line">QuerySET SESSION lock_wait_timeout=60</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'wait\_timeout'</span></span><br><span class="line">QuerySET SESSION wait_timeout=10000</span><br><span class="line">QuerySELECT @@SQL_MODE</span><br><span class="line">QuerySET @@SQL_QUOTE_SHOW_CREATE = 1/*!40101, @@SQL_MODE=<span class="string">'NO_AUTO_VALUE_ON_ZERO,PIPES_AS_CONCAT,ANSI_QUOTES,NO_AUTO_VALUE_ON_ZERO,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span>*/</span><br><span class="line">QuerySELECT @@server_id /*!50038 , @@hostname*/</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'wsrep_on'</span></span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'version%'</span></span><br><span class="line">QuerySHOW ENGINES</span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'innodb_version'</span></span><br><span class="line">QuerySHOW VARIABLES LIKE <span class="string">'innodb_stats_persistent'</span></span><br><span class="line">QuerySELECT @@SERVER_ID</span><br><span class="line">QuerySHOW SLAVE HOSTS</span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QuerySELECT CONCAT(@@hostname, @@port)</span><br><span class="line">QuerySHOW TABLES FROM `<span class="built_in">test</span>` LIKE <span class="string">'p\_test'</span></span><br><span class="line">QuerySELECT VERSION()</span><br><span class="line">QuerySHOW TRIGGERS FROM `<span class="built_in">test</span>` LIKE <span class="string">'p\_test'</span></span><br><span class="line">Query/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := <span class="string">''</span>, @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */</span><br><span class="line">QueryUSE `<span class="built_in">test</span>`</span><br><span class="line">QuerySHOW CREATE TABLE `<span class="built_in">test</span>`.`p_test`</span><br><span class="line">Query/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */</span><br><span class="line">QueryEXPLAIN SELECT * FROM `<span class="built_in">test</span>`.`p_test` WHERE 1=1</span><br><span class="line">QuerySELECT table_schema, table_name FROM information_schema.key_column_usage WHERE referenced_table_schema=<span class="string">'test'</span> AND referenced_table_name=<span class="string">'p_test'</span></span><br><span class="line">Query/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := <span class="string">''</span>, @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */</span><br><span class="line">QueryUSE `<span class="built_in">test</span>`</span><br><span class="line">QuerySHOW CREATE TABLE `<span class="built_in">test</span>`.`p_test`</span><br><span class="line">Query/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */</span><br><span class="line">QueryCREATE TABLE `<span class="built_in">test</span>`.`_p_test_new` (</span><br><span class="line">  `user_id` varchar(20) NOT NULL,</span><br><span class="line">  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">QueryALTER TABLE `<span class="built_in">test</span>`.`_p_test_new` ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST, DROP PRIMARY KEY, ADD PRIMARY KEY (id, create_time), ADD UNIQUE INDEX uniq_ui_ct(user_id, create_time)</span><br><span class="line">Query/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, @@SQL_MODE := <span class="string">''</span>, @OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, @@SQL_QUOTE_SHOW_CREATE := 1 */</span><br><span class="line">QueryUSE `<span class="built_in">test</span>`</span><br><span class="line">QuerySHOW CREATE TABLE `<span class="built_in">test</span>`.`_p_test_new`</span><br><span class="line">Query/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, @@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */</span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'DELETE'</span>    AND ACTION_TIMING = <span class="string">'AFTER'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'UPDATE'</span>    AND ACTION_TIMING = <span class="string">'AFTER'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'INSERT'</span>    AND ACTION_TIMING = <span class="string">'AFTER'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'DELETE'</span>    AND ACTION_TIMING = <span class="string">'BEFORE'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'UPDATE'</span>    AND ACTION_TIMING = <span class="string">'BEFORE'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QuerySELECT TRIGGER_SCHEMA, TRIGGER_NAME, DEFINER, ACTION_STATEMENT, SQL_MODE,        CHARACTER_SET_CLIENT, COLLATION_CONNECTION, EVENT_MANIPULATION, ACTION_TIMING   FROM INFORMATION_SCHEMA.TRIGGERS  WHERE EVENT_MANIPULATION = <span class="string">'INSERT'</span>    AND ACTION_TIMING = <span class="string">'BEFORE'</span>    AND TRIGGER_SCHEMA = <span class="string">'test'</span>    AND EVENT_OBJECT_TABLE = <span class="string">'p_test'</span></span><br><span class="line">QueryCREATE TRIGGER `pt_osc_test_p_test_del` AFTER DELETE ON `<span class="built_in">test</span>`.`p_test` FOR EACH ROW DELETE IGNORE FROM `<span class="built_in">test</span>`.`_p_test_new` WHERE `<span class="built_in">test</span>`.`_p_test_new`.`user_id` &lt;=&gt; OLD.`user_id`</span><br><span class="line">QueryCREATE TRIGGER `pt_osc_test_p_test_upd` AFTER UPDATE ON `<span class="built_in">test</span>`.`p_test` FOR EACH ROW BEGIN DELETE IGNORE FROM `<span class="built_in">test</span>`.`_p_test_new` WHERE !(OLD.`user_id` &lt;=&gt; NEW.`user_id`) AND `<span class="built_in">test</span>`.`_p_test_new`.`user_id` &lt;=&gt; OLD.`user_id`;REPLACE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) VALUES (NEW.`user_id`, NEW.`create_time`);END</span><br><span class="line">QueryCREATE TRIGGER `pt_osc_test_p_test_ins` AFTER INSERT ON `<span class="built_in">test</span>`.`p_test` FOR EACH ROW REPLACE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) VALUES (NEW.`user_id`, NEW.`create_time`)</span><br><span class="line">QueryEXPLAIN SELECT * FROM `<span class="built_in">test</span>`.`p_test` WHERE 1=1</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) ORDER BY `user_id` LIMIT 1 /*first lower boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX (`PRIMARY`) WHERE `user_id` IS NOT NULL ORDER BY `user_id` LIMIT 1 /*key_len*/</span><br><span class="line">QueryEXPLAIN SELECT /*!40001 SQL_NO_CACHE */ * FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX (`PRIMARY`) WHERE `user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span> /*key_len*/</span><br><span class="line">QueryEXPLAIN SELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) ORDER BY `user_id` LIMIT 999, 2 /*next chunk boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) ORDER BY `user_id` LIMIT 999, 2 /*next chunk boundary*/</span><br><span class="line">QueryEXPLAIN SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) AND ((`user_id` &lt;= <span class="string">'bdn57bnaz9UXTpdFzH'</span>)) LOCK IN SHARE MODE /*explain pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QueryINSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) AND ((`user_id` &lt;= <span class="string">'bdn57bnaz9UXTpdFzH'</span>)) LOCK IN SHARE MODE /*pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QuerySHOW WARNINGS</span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QueryEXPLAIN SELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'bdo8j11Q2whGrZujWB'</span>)) ORDER BY `user_id` LIMIT 2237, 2 /*next chunk boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'bdo8j11Q2whGrZujWB'</span>)) ORDER BY `user_id` LIMIT 2237, 2 /*next chunk boundary*/</span><br><span class="line">QueryEXPLAIN SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'bdo8j11Q2whGrZujWB'</span>)) AND ((`user_id` &lt;= <span class="string">'Ox7PCp52KsU1fYXJAB'</span>)) LOCK IN SHARE MODE /*explain pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QueryINSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'bdo8j11Q2whGrZujWB'</span>)) AND ((`user_id` &lt;= <span class="string">'Ox7PCp52KsU1fYXJAB'</span>)) LOCK IN SHARE MODE /*pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QuerySHOW WARNINGS</span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QueryEXPLAIN SELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'OXcX149l9zca2yuCrc'</span>)) ORDER BY `user_id` LIMIT 2076, 2 /*next chunk boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'OXcX149l9zca2yuCrc'</span>)) ORDER BY `user_id` LIMIT 2076, 2 /*next chunk boundary*/</span><br><span class="line">QuerySELECT /*!40001 SQL_NO_CACHE */ `user_id` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) ORDER BY `user_id` DESC LIMIT 1 /*last upper boundary*/</span><br><span class="line">QueryEXPLAIN SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'OXcX149l9zca2yuCrc'</span>)) AND ((`user_id` &lt;= <span class="string">'zzY2454Vegqcz6CC3i'</span>)) LOCK IN SHARE MODE /*explain pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QueryINSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'OXcX149l9zca2yuCrc'</span>)) AND ((`user_id` &lt;= <span class="string">'zzY2454Vegqcz6CC3i'</span>)) LOCK IN SHARE MODE /*pt-online-schema-change 31941 copy nibble*/</span><br><span class="line">QuerySHOW WARNINGS</span><br><span class="line">QuerySHOW GLOBAL STATUS LIKE <span class="string">'Threads_running'</span></span><br><span class="line">QueryANALYZE TABLE `<span class="built_in">test</span>`.`_p_test_new` /* pt-online-schema-change */</span><br><span class="line">QueryRENAME TABLE `<span class="built_in">test</span>`.`p_test` TO `<span class="built_in">test</span>`.`_p_test_old`, `<span class="built_in">test</span>`.`_p_test_new` TO `<span class="built_in">test</span>`.`p_test`</span><br><span class="line">QueryDROP TABLE IF EXISTS `<span class="built_in">test</span>`.`_p_test_old`</span><br><span class="line">QueryDROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_del`</span><br><span class="line">QueryDROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_upd`</span><br><span class="line">QueryDROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_ins`</span><br><span class="line">QuerySHOW TABLES FROM `<span class="built_in">test</span>` LIKE <span class="string">'\_p\_test\_new'</span></span><br></pre></td></tr></table></figure></p><h2 id="连接数据库，获取指定表的状态信息、触发器信息、权限信息和主键信息"><a href="#连接数据库，获取指定表的状态信息、触发器信息、权限信息和主键信息" class="headerlink" title="连接数据库，获取指定表的状态信息、触发器信息、权限信息和主键信息"></a>连接数据库，获取指定表的状态信息、触发器信息、权限信息和主键信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost on <span class="built_in">test</span> using Socket</span><br><span class="line">SHOW TRIGGERS FROM `<span class="built_in">test</span>` LIKE <span class="string">'p\_test'</span></span><br><span class="line">SELECT table_schema, table_name FROM information_schema.key_column_usage WHERE referenced_table_schema=<span class="string">'test'</span> AND referenced_table_name=<span class="string">'p_test'</span></span><br><span class="line">SHOW CREATE TABLE `<span class="built_in">test</span>`.`p_test`</span><br></pre></td></tr></table></figure><h2 id="新建-new，表结构与原表相同。"><a href="#新建-new，表结构与原表相同。" class="headerlink" title="新建_*_new，表结构与原表相同。"></a>新建<code>_*_new</code>，表结构与原表相同。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `<span class="built_in">test</span>`.`_p_test_new` (</span><br><span class="line">  `user_id` varchar(20) NOT NULL,</span><br><span class="line">  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="在新表上执行DDL操作表结构，更改表结构"><a href="#在新表上执行DDL操作表结构，更改表结构" class="headerlink" title="在新表上执行DDL操作表结构，更改表结构"></a>在新表上执行DDL操作表结构，更改表结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `<span class="built_in">test</span>`.`_p_test_new` ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST, DROP PRIMARY KEY,ADD PRIMARY KEY (id);</span><br></pre></td></tr></table></figure><h2 id="在原表上分别针对insert、update、delete操作三个触发器分别，以便后续对原表上的操作同步到新表"><a href="#在原表上分别针对insert、update、delete操作三个触发器分别，以便后续对原表上的操作同步到新表" class="headerlink" title="在原表上分别针对insert、update、delete操作三个触发器分别，以便后续对原表上的操作同步到新表"></a>在原表上分别针对insert、update、delete操作三个触发器分别，以便后续对原表上的操作同步到新表</h2><p>Creating triggers ……<br>创建触发器，用于记录从拷贝数据开始之后，对源数据表继续进行数据修改的操作记录下来，用于数据拷贝结束后，执行这些操作，保证数据不会丢失。如果表中已经定义了触发器这个工具就不能工作了。我们可以看到这三个触发器分别对应于INSERT、UPDATE、DELETE三种操作：<br>  a、CREATE TRIGGER <code>pt_osc_test_p_test_del</code> AFTER DELETE ON <code>test</code>.<code>p_test</code> FOR EACH ROW DELETE IGNORE FROM <code>test</code>.<code>_p_test_new</code> WHERE <code>test</code>.<code>_p_test_new</code>.<code>user_id</code> &lt;=&gt; OLD.<code>user_id</code><br>  pt_osc_test_online_table_del，DELETE操作，我们注意到DELETE IGNORE，当新有数据时，我们才进行操作，也就是说，当在后续导入过程中，如果删除的这个数据还未导入到新表，那么我们可以不在新表执行操作，因为在以后的导入过程中，原表中改行数据已经被删除，已经没有数据，那么他也就不会导入到新表中。<br>  b、CREATE TRIGGER <code>pt_osc_test_p_test_upd</code> AFTER UPDATE ON <code>test</code>.<code>p_test</code> FOR EACH ROW BEGIN DELETE IGNORE FROM <code>test</code>.<code>_p_test_new</code> WHERE !(OLD.<code>user_id</code> &lt;=&gt; NEW.<code>user_id</code>) AND <code>test</code>.<code>_p_test_new</code>.<code>user_id</code> &lt;=&gt; OLD.<code>user_id</code>;REPLACE INTO <code>test</code>.<code>_p_test_new</code> (<code>user_id</code>, <code>create_time</code>) VALUES (NEW.<code>user_id</code>, NEW.<code>create_time</code>);END<br>  pt_osc_test_online_table_ins，INSERT操作，所有的INSERT INTO全部转换为REPLACE INTO，为了确保数据的一致性，当有新数据插入到原表时，如果触发器还未把原表数据未同步到新表，这条数据已经被导入到新表了，那么我们就可以利用replace into进行覆盖，这样数据也是一致的。<br>  c、 CREATE TRIGGER <code>pt_osc_test_p_test_ins</code> AFTER INSERT ON <code>test</code>.<code>p_test</code> FOR EACH ROW REPLACE INTO <code>test</code>.<code>_p_test_new</code> (<code>user_id</code>, <code>create_time</code>) VALUES (NEW.<code>user_id</code>, NEW.<code>create_time</code>)<br>  pt_osc_test_online_table_upd，UPDATE操作，所有的UPDATE也转换为REPLACE INTO，因为当新的数据的行还未同步到新表时，新表是不存在这条记录的，那么我们就只能插入该条数据，如果已经同步到新表了，那么也可以进行覆盖插入，所有数据与原表也是一致的。</p><h2 id="拷贝原表数据到新表，数据量大时根据主键进行分-chunk-段插入。"><a href="#拷贝原表数据到新表，数据量大时根据主键进行分-chunk-段插入。" class="headerlink" title="拷贝原表数据到新表，数据量大时根据主键进行分 chunk 段插入。"></a>拷贝原表数据到新表，数据量大时根据主键进行分 chunk 段插入。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` FORCE INDEX(`PRIMARY`) WHERE ((`user_id` &gt;= <span class="string">'00R7TVLSWXKJgVHzA4'</span>)) AND ((`user_id` &lt;= <span class="string">'bdn57bnaz9UXTpdFzH'</span>)) LOCK IN SHARE MODE /*pt-online-schema-change 31941 copy nibble*/</span><br></pre></td></tr></table></figure><p>数据的拷贝是基于chunk指定的大小块(根据chunk-time参数指定)进行的，而且根据主键或者唯一索引索引进行选择，所以对整体服务器性能影响较小。它是通过一些查询（基本为主键、唯一键值）分批把数据导入到新的表中。在拷贝过程中，数据库通过对主键加S锁，拷贝数据。</p><h2 id="ANALYZE重新收集新表统计信息"><a href="#ANALYZE重新收集新表统计信息" class="headerlink" title="ANALYZE重新收集新表统计信息"></a>ANALYZE重新收集新表统计信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE TABLE `<span class="built_in">test</span>`.`_p_test_new`</span><br></pre></td></tr></table></figure><h2 id="交换表，其通过一个RENAME-TABLE同时处理两个表，实现原子操作。"><a href="#交换表，其通过一个RENAME-TABLE同时处理两个表，实现原子操作。" class="headerlink" title="交换表，其通过一个RENAME TABLE同时处理两个表，实现原子操作。"></a>交换表，其通过一个RENAME TABLE同时处理两个表，实现原子操作。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE `<span class="built_in">test</span>`.`p_test` TO `<span class="built_in">test</span>`.`_p_test_old`, `<span class="built_in">test</span>`.`_p_test_new` TO `<span class="built_in">test</span>`.`p_test`</span><br></pre></td></tr></table></figure><p>在这个过程中，会持有锁。</p><h2 id="如果没有定义–no-drop-old-table，清理以上过程中的old表、创建的触发器。"><a href="#如果没有定义–no-drop-old-table，清理以上过程中的old表、创建的触发器。" class="headerlink" title="如果没有定义–no-drop-old-table，清理以上过程中的old表、创建的触发器。"></a>如果没有定义–no-drop-old-table，清理以上过程中的old表、创建的触发器。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `<span class="built_in">test</span>`.`_p_test_old`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_del`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_upd`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_ins`</span><br></pre></td></tr></table></figure><h1 id="pt-online-schema-change-用法及核心参数"><a href="#pt-online-schema-change-用法及核心参数" class="headerlink" title="pt-online-schema-change 用法及核心参数"></a>pt-online-schema-change 用法及核心参数</h1><p>–alter-foreign-keys-method<br>如何把外键引用到新表？需要特殊处理带有外键约束的表，以保证它们可以应用到新表。当重命名表的时候，外键关系会带到重命名后的表上。该工具有两种方法，可以自动找到子表，并修改约束关系。</p><p>–[no]check-replication-filters<br>默认yes，如果工具检测到服务器选项中有任何复制相关的筛选，如指定binlog_ignore_db和replicate_do_db此类。发现有这样的筛选，工具会报错且退出。因为如果更新的表Master上存在，而Slave上不存在，会导致复制的失败。使用 –no-check-replication-filters选项来禁用该检查。</p><p>–max-load<br>默认为Threads_running=25。每个chunk拷贝完后，会检查SHOW GLOBAL STATUS的内容，检查指标是否超过了指定的阈值。如果超过，则先暂停。这里可以用逗号分隔，指定多个条件，每个条件格式：status指标=MAX_VALUE或者status指标:MAX_VALUE。如果不指定MAX_VALUE，那么工具会这只其为当前值的120%。</p><p>–max-lag<br>默认1s。每个chunk拷贝完成后，会查看所有复制Slave的延迟情况（Seconds_Behind_Master）。要是延迟大于该值，则暂停复制数据，直到所有从的滞后小于这个值。–check-interval 配合使用，指定出现从库滞后超过 max-lag，则该工具将睡眠多长时间，默认1s，再检查。如–max-lag=5 –check-interval=2</p><p>–chunk-time<br>在chunk-time执行的时间内，动态调整chunk-size的大小，以适应服务器性能的变化，该参数设置为0。或者指定chunk-size，都可以禁止动态调整。</p><p>–chunk-size<br>指定块的大小，默认是1000行，可以添加k,M,G后缀。这个块的大小要尽量与 –chunk-time匹配，如果明确指定这个选项，那么每个块就会指定行数的大小。</p><p>–dry-run<br>创建和修改新表，但不会创建触发器、复制数据、和替换原表。并不真正执行，可以看到生成的执行语句，了解其执行步骤与细节。 –dry-run 与 –execute 必须指定一个，二者相互排斥。和–print配合最佳。</p><h1 id="pt-online-schema-change-实战"><a href="#pt-online-schema-change-实战" class="headerlink" title="pt-online-schema-change 实战"></a>pt-online-schema-change 实战</h1><h2 id="简单的修改字段和增删索引"><a href="#简单的修改字段和增删索引" class="headerlink" title="简单的修改字段和增删索引"></a>简单的修改字段和增删索引</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"ADD COLUMN channal tinyint(4) UNSIGNED NOT NULL;"</span> \</span><br><span class="line">--max-lag=1 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><h2 id="修改主键或唯一索引操作"><a href="#修改主键或唯一索引操作" class="headerlink" title="修改主键或唯一索引操作"></a>修改主键或唯一索引操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增主键ID' FIRST, DROP PRIMARY KEY, </span></span><br><span class="line"><span class="string">ADD PRIMARY KEY (id), ADD UNIQUE INDEX uniq_ui_ct(user_id);"</span> \</span><br><span class="line">--no-check-unique-key-change --no-check-alter --max-lag=1 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><h2 id="重定义分区表操作"><a href="#重定义分区表操作" class="headerlink" title="重定义分区表操作"></a>重定义分区表操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"PARTITION BY RANGE COLUMNS(create_time)(</span></span><br><span class="line"><span class="string"> PARTITION p01 VALUES LESS THAN ('2017-01-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p02 VALUES LESS THAN ('2017-02-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p03 VALUES LESS THAN ('2017-03-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p04 VALUES LESS THAN ('2017-04-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p00 VALUES LESS THAN (MAXVALUE));"</span> \</span><br><span class="line">--max-lag=1 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><h2 id="存在主外键关联表字段操作"><a href="#存在主外键关联表字段操作" class="headerlink" title="存在主外键关联表字段操作"></a>存在主外键关联表字段操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">""</span> \</span><br><span class="line">--alter-foreign-keys-method=rebuild_constraints --max-lag=1 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><h2 id="主从环境下的字段操作"><a href="#主从环境下的字段操作" class="headerlink" title="主从环境下的字段操作"></a>主从环境下的字段操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">""</span> \</span><br><span class="line">--no-check-replication-filters --max-lag=1 --max-lag=2 --<span class="built_in">print</span> --execute</span><br></pre></td></tr></table></figure><p>参考文档：<br>pt-online-schema-change在线修改表结构：<a href="http://www.ywnds.com/?p=4442" target="_blank" rel="noopener">http://www.ywnds.com/?p=4442</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;pt-online-schema-change-背景&quot;&gt;&lt;a href=&quot;#pt-online-schema-change-背景&quot; class=&quot;headerlink&quot; title=&quot;pt-online-schema-change
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="pt-tools" scheme="http://yoursite.com/tags/pt-tools/"/>
    
  </entry>
  
  <entry>
    <title>pt-online-schema-change 实现 MySQL 在线重定义普通表转分区表</title>
    <link href="http://yoursite.com/2018/04/18/MySQL/MySQL_Partition/"/>
    <id>http://yoursite.com/2018/04/18/MySQL/MySQL_Partition/</id>
    <published>2018-04-18T11:48:56.124Z</published>
    <updated>2018-04-18T21:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p><h1 id="表分区缘由"><a href="#表分区缘由" class="headerlink" title="表分区缘由"></a>表分区缘由</h1><p>1、表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他都是历史数据<br>2、分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备<br>3、优化查询，在where字句中包含分区列时，可以只使用必要的分区来提高查询效率，同时在涉及sum()和count()这类聚合函数的查询时，可以在每个分区上面并行处理，最终只需要汇总所有分区得到的结果。<br>4、如果需要，还可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好<br>5、分区表的数据更容易维护，如：想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作</p><h1 id="分区表设计"><a href="#分区表设计" class="headerlink" title="分区表设计"></a>分区表设计</h1><p>对于生产中一个普通字符串主键的大表，我们该如何在不影响前端业务的情况下，将其改造成分区表。例如普通表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"p_test"</span> (</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"user_id"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>我们该如何设计这种表的分区表，来隔离冷热数据，MySQL 5.7 版本后COLUMNS分区支持对整形、字符串、日期和时间撮等各类型数据分区，分区跨度可随数据规模定义，可设计为按月、按日分区或者按小时分区。具体分区表设计如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"p_test"</span> (</span><br><span class="line">  <span class="string">"id"</span> int(20) NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">"user_id"</span> varchar(32) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_ui_ct"</span> (<span class="string">"user_id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">/*!50500 PARTITION BY RANGE COLUMNS(create_time)</span><br><span class="line">(PARTITION p01 VALUES LESS THAN (<span class="string">'2018-01-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p02 VALUES LESS THAN (<span class="string">'2018-02-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p03 VALUES LESS THAN (<span class="string">'2018-03-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p04 VALUES LESS THAN (<span class="string">'2018-04-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p00 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */;</span><br></pre></td></tr></table></figure></p><p>看到 PRIMARY KEY (“id”,”create_time”),UNIQUE KEY “uniq_ui_ct” (“user_id”,”create_time”)也许会疑惑，为什么要对自增主键和唯一索引添加create_time的复合主键和联合唯一索引，这是因为range的分区要求唯一索引类必须和分区键搭配构成分区表的唯一索引，不然会报错误：1503 - A PRIMARY KEY/UNIQUE INDEX must include all columns in the table’s partitioning function。<br>还有一个原因，就是修改主键影响最大的就是 DELETE 触发器，新表上的主键字段在旧表上不存在，无法根据主键条件触发删除新表数据。而对于INSERT,UPDATE的触发器，依然是 REPLACE INTO语法，因为它采用的是先插入，如果违反主键或唯一约束，则根据主键或意义约束删除这条数据，再执行插入。所以如果使用pt-osc去修改删除主键，务必同时添加原主键为 UNIQUE KEY，否则很有可能导致性能问题。</p><h1 id="pt-osc-实现在线重定义分区表原理"><a href="#pt-osc-实现在线重定义分区表原理" class="headerlink" title="pt-osc 实现在线重定义分区表原理"></a>pt-osc 实现在线重定义分区表原理</h1><p>在实现过程中，我也试图只通过一次 pt-osc 过程来实现在线重定义分区表的过程，但是 MySQL DDL语法并不支持同时对分区和普通DDL操作，实现过程如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:<span class="built_in">test</span>&gt;ALTER TABLE <span class="string">"p_test"</span> </span><br><span class="line">    -&gt; ADD COLUMN <span class="string">"id"</span> bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST,</span><br><span class="line">    -&gt; DROP PRIMARY KEY,</span><br><span class="line">    -&gt; ADD PRIMARY KEY (<span class="string">"id"</span>, <span class="string">"create_time"</span>),</span><br><span class="line">    -&gt; ADD UNIQUE INDEX <span class="string">"uniq_ui_ct"</span>(<span class="string">"user_id"</span>, <span class="string">"create_time"</span>);</span><br><span class="line">Query OK, 0 rows affected (0.33 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">root@localhost:<span class="built_in">test</span>&gt;Alter table <span class="string">"p_test"</span> PARTITION BY RANGE COLUMNS(create_time)</span><br><span class="line">    -&gt; (PARTITION p01 VALUES LESS THAN (<span class="string">'2017-01-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p02 VALUES LESS THAN (<span class="string">'2017-02-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p03 VALUES LESS THAN (<span class="string">'2017-03-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p04 VALUES LESS THAN (<span class="string">'2017-04-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p00 VALUES LESS THAN (MAXVALUE));</span><br><span class="line">Query OK, 0 rows affected (1.49 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">root@localhost:<span class="built_in">test</span>&gt;ALTER TABLE <span class="string">"p_test"</span> </span><br><span class="line">    -&gt; ADD COLUMN <span class="string">"id"</span> bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST,</span><br><span class="line">    -&gt; DROP PRIMARY KEY,</span><br><span class="line">    -&gt; ADD PRIMARY KEY (<span class="string">"id"</span>, <span class="string">"create_time"</span>),</span><br><span class="line">    -&gt; ADD UNIQUE INDEX <span class="string">"uniq_ui_ct"</span>(<span class="string">"user_id"</span>, <span class="string">"create_time"</span>),</span><br><span class="line">    -&gt; PARTITION BY RANGE COLUMNS(create_time)</span><br><span class="line">    -&gt; (PARTITION p01 VALUES LESS THAN (<span class="string">'2017-01-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p02 VALUES LESS THAN (<span class="string">'2017-02-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p03 VALUES LESS THAN (<span class="string">'2017-03-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p04 VALUES LESS THAN (<span class="string">'2017-04-01 00:00:00'</span>),</span><br><span class="line">    -&gt;  PARTITION p00 VALUES LESS THAN (MAXVALUE));</span><br><span class="line">ERROR 1064 (42000): You have an error <span class="keyword">in</span> your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">'PARTITION BY RANGE COLUMNS(create_time)</span></span><br><span class="line"><span class="string">(PARTITION p01 VALUES LESS THAN ('</span>2017-0<span class="string">' at line 6</span></span><br></pre></td></tr></table></figure></p><p>为了便于观察和理解 pt-osc 实现过程在线重定义过程，我们通过 –no-drop-old-table 保留原普通表结构和数据</p><h2 id="pt-osc-修改表主键"><a href="#pt-osc-修改表主键" class="headerlink" title="pt-osc 修改表主键"></a>pt-osc 修改表主键</h2><p>pt-osc 实现修改主键过程和原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增主键ID' FIRST, DROP PRIMARY KEY, </span></span><br><span class="line"><span class="string">ADD PRIMARY KEY (id, create_time), ADD UNIQUE INDEX uniq_ui_ct(user_id, create_time);"</span> \</span><br><span class="line">--no-check-unique-key-change --no-check-alter --no-drop-old-table --<span class="built_in">print</span> --dry-run</span><br><span class="line"></span><br><span class="line">Operation, tries, <span class="built_in">wait</span>:</span><br><span class="line">  analyze_table, 10, 1</span><br><span class="line">  copy_rows, 10, 0.25</span><br><span class="line">  create_triggers, 10, 1</span><br><span class="line">  drop_triggers, 10, 1</span><br><span class="line">  swap_tables, 10, 1</span><br><span class="line">  update_foreign_keys, 10, 1</span><br><span class="line">Starting a dry run.  `<span class="built_in">test</span>`.`p_test` will not be altered.  Specify --execute instead of --dry-run to alter the table.</span><br><span class="line">Creating new table...</span><br><span class="line">CREATE TABLE `<span class="built_in">test</span>`.`_p_test_new` (</span><br><span class="line">  `user_id` varchar(20) NOT NULL,</span><br><span class="line">  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (`user_id`),</span><br><span class="line">  KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">Created new table test._p_test_new OK.</span><br><span class="line">Altering new table...</span><br><span class="line">ALTER TABLE `<span class="built_in">test</span>`.`_p_test_new` ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span> FIRST, DROP PRIMARY KEY, </span><br><span class="line">ADD PRIMARY KEY (id, create_time), ADD UNIQUE INDEX uniq_ui_ct(user_id, create_time);</span><br><span class="line">Altered `<span class="built_in">test</span>`.`_p_test_new` OK.</span><br><span class="line">Using original table index PRIMARY <span class="keyword">for</span> the DELETE trigger instead of new table index PRIMARY because the new table index uses column id <span class="built_in">which</span> does not exist <span class="keyword">in</span> the original table.</span><br><span class="line">Not creating triggers because this is a dry run.</span><br><span class="line">Not copying rows because this is a dry run.</span><br><span class="line">INSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`user_id`, `create_time`) SELECT `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` LOCK IN SHARE MODE /*pt-online-schema-change 10134 copy table*/</span><br><span class="line">Not swapping tables because this is a dry run.</span><br><span class="line">Not dropping old table because this is a dry run.</span><br><span class="line">Not dropping triggers because this is a dry run.</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_del`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_upd`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_ins`</span><br><span class="line">2018-04-18T15:10:26 Dropping new table...</span><br><span class="line">DROP TABLE IF EXISTS `<span class="built_in">test</span>`.`_p_test_new`;</span><br><span class="line">2018-04-18T15:10:26 Dropped new table OK.</span><br><span class="line">Dry run complete.  `<span class="built_in">test</span>`.`p_test` was not altered.</span><br></pre></td></tr></table></figure></p><p>操作、实现过程修改主键如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"ADD COLUMN id bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增主键ID' FIRST, DROP PRIMARY KEY, </span></span><br><span class="line"><span class="string">ADD PRIMARY KEY (id, create_time), ADD UNIQUE INDEX uniq_ui_ct(user_id, create_time);"</span> \</span><br><span class="line">--no-check-unique-key-change --no-check-alter --no-drop-old-table --max-lag=1 --execute</span><br></pre></td></tr></table></figure></p><p>对比 _p_test_new 和 p_test 表结构，符合预期，表主键已经由 varchar 字符串主键修改为自增和 datetime 类型联合主键类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"_p_test_old"</span> (</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"user_id"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">"p_test"</span> (</span><br><span class="line">  <span class="string">"id"</span> bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_ui_ct"</span> (<span class="string">"user_id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><h2 id="pt-osc-在线重定义分区表"><a href="#pt-osc-在线重定义分区表" class="headerlink" title="pt-osc 在线重定义分区表"></a>pt-osc 在线重定义分区表</h2><p>在线重定义普通表转分区表过程和原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"PARTITION BY RANGE COLUMNS(create_time)(</span></span><br><span class="line"><span class="string"> PARTITION p01 VALUES LESS THAN ('2017-01-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p02 VALUES LESS THAN ('2017-02-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p03 VALUES LESS THAN ('2017-03-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p04 VALUES LESS THAN ('2017-04-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p00 VALUES LESS THAN (MAXVALUE));"</span> \</span><br><span class="line">--no-drop-old-table --max-lag=1 --<span class="built_in">print</span> --dry-run</span><br><span class="line"></span><br><span class="line">Operation, tries, <span class="built_in">wait</span>:</span><br><span class="line">  analyze_table, 10, 1</span><br><span class="line">  copy_rows, 10, 0.25</span><br><span class="line">  create_triggers, 10, 1</span><br><span class="line">  drop_triggers, 10, 1</span><br><span class="line">  swap_tables, 10, 1</span><br><span class="line">  update_foreign_keys, 10, 1</span><br><span class="line">Starting a dry run.  `<span class="built_in">test</span>`.`p_test` will not be altered.  Specify --execute instead of --dry-run to alter the table.</span><br><span class="line">Creating new table...</span><br><span class="line">CREATE TABLE `<span class="built_in">test</span>`.`_p_test_new` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  `user_id` varchar(20) NOT NULL,</span><br><span class="line">  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (`id`,`create_time`),</span><br><span class="line">  UNIQUE KEY `uniq_ui_ct` (`user_id`,`create_time`),</span><br><span class="line">  KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2048 DEFAULT CHARSET=utf8</span><br><span class="line">Created new table test._p_test_new OK.</span><br><span class="line">Altering new table...</span><br><span class="line">ALTER TABLE `<span class="built_in">test</span>`.`_p_test_new` PARTITION BY RANGE COLUMNS(create_time)(</span><br><span class="line"> PARTITION p01 VALUES LESS THAN (<span class="string">'2017-01-01 00:00:00'</span>),</span><br><span class="line"> PARTITION p02 VALUES LESS THAN (<span class="string">'2017-02-01 00:00:00'</span>),</span><br><span class="line"> PARTITION p03 VALUES LESS THAN (<span class="string">'2017-03-01 00:00:00'</span>),</span><br><span class="line"> PARTITION p04 VALUES LESS THAN (<span class="string">'2017-04-01 00:00:00'</span>),</span><br><span class="line"> PARTITION p00 VALUES LESS THAN (MAXVALUE));</span><br><span class="line">Altered `<span class="built_in">test</span>`.`_p_test_new` OK.</span><br><span class="line">Not creating triggers because this is a dry run.</span><br><span class="line">Not copying rows because this is a dry run.</span><br><span class="line">INSERT LOW_PRIORITY IGNORE INTO `<span class="built_in">test</span>`.`_p_test_new` (`id`, `user_id`, `create_time`) SELECT `id`, `user_id`, `create_time` FROM `<span class="built_in">test</span>`.`p_test` LOCK IN SHARE MODE /*pt-online-schema-change 5211 copy table*/</span><br><span class="line">Not swapping tables because this is a dry run.</span><br><span class="line">Not dropping old table because --no-drop-old-table was specified.</span><br><span class="line">Not dropping triggers because this is a dry run.</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_del`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_upd`</span><br><span class="line">DROP TRIGGER IF EXISTS `<span class="built_in">test</span>`.`pt_osc_test_p_test_ins`</span><br><span class="line">2018-04-18T10:23:47 Dropping new table...</span><br><span class="line">DROP TABLE IF EXISTS `<span class="built_in">test</span>`.`_p_test_new`;</span><br><span class="line">2018-04-18T10:23:47 Dropped new table OK.</span><br><span class="line">Dry run complete.  `<span class="built_in">test</span>`.`p_test` was not altered.</span><br></pre></td></tr></table></figure></p><p>实现在线重定义分区表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change -uroot -poRcl_123 -hlocalhost -P3307 D=<span class="built_in">test</span>,t=p_test \</span><br><span class="line">--alter <span class="string">"PARTITION BY RANGE COLUMNS(create_time)(</span></span><br><span class="line"><span class="string"> PARTITION p01 VALUES LESS THAN ('2017-01-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p02 VALUES LESS THAN ('2017-02-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p03 VALUES LESS THAN ('2017-03-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p04 VALUES LESS THAN ('2017-04-01 00:00:00'),</span></span><br><span class="line"><span class="string"> PARTITION p00 VALUES LESS THAN (MAXVALUE));"</span> \</span><br><span class="line">--no-drop-old-table --max-lag=1 --execute</span><br></pre></td></tr></table></figure></p><p>对比 __p_test_new 和 p_test 表结构，符合预期结果，表被定义为分区表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">"p_test"</span> (</span><br><span class="line">  <span class="string">"id"</span> bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_ui_ct"</span> (<span class="string">"user_id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2048 DEFAULT CHARSET=utf8</span><br><span class="line">/*!50500 PARTITION BY RANGE  COLUMNS(create_time)</span><br><span class="line">(PARTITION p01 VALUES LESS THAN (<span class="string">'2017-01-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p02 VALUES LESS THAN (<span class="string">'2017-02-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p03 VALUES LESS THAN (<span class="string">'2017-03-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p04 VALUES LESS THAN (<span class="string">'2017-04-01 00:00:00'</span>) ENGINE = InnoDB,</span><br><span class="line"> PARTITION p00 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */;</span><br><span class="line"></span><br><span class="line"> CREATE TABLE <span class="string">"__p_test_old"</span> (</span><br><span class="line">  <span class="string">"id"</span> bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">"user_id"</span> varchar(20) NOT NULL,</span><br><span class="line">  <span class="string">"create_time"</span> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">'记录创建时间'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">"id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  UNIQUE KEY <span class="string">"uniq_ui_ct"</span> (<span class="string">"user_id"</span>,<span class="string">"create_time"</span>),</span><br><span class="line">  KEY <span class="string">"idx_create_time"</span> (<span class="string">"create_time"</span>)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2048 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p>总结pt-osc实现在线重定义普通标转分区表原理：<br>pt-osc 首先创建一个不可见的临时表，然后对临时表修改表结构或者重定义分区表，再后创建更新、删除、插入3个触发器，按一个chunk-size大小拷贝数据，拷贝过程中对chunk块持有s锁，同时对新增的insert、update、delete操作通过触发器写入临时表，因为有唯一索引 uniq_ui_ct 避免了 update 和 delete 操作导致可能对临时表的全表扫描，复制操作完成后，analyze 新表，重新 rename 表名，删除普通表、触发器，锁只会存在对每一个 chunk 复制和 rename 表名的时候。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;MySQL
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="pt-tools" scheme="http://yoursite.com/tags/pt-tools/"/>
    
      <category term="MySQL 优化" scheme="http://yoursite.com/tags/MySQL-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
